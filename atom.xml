<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>萌面喵喵侠</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lolico.me/"/>
  <updated>2022-04-09T14:18:50.404Z</updated>
  <id>https://lolico.me/</id>
  
  <author>
    <name>萌面喵喵侠</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最优解</title>
    <link href="https://lolico.me/2022/04/05/%E6%9C%80%E4%BC%98%E8%A7%A3/"/>
    <id>https://lolico.me/2022/04/05/%E6%9C%80%E4%BC%98%E8%A7%A3/</id>
    <published>2022-04-05T14:53:05.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --><p>如果将交往看成一个找最优解问题，普通朋友能做到局部最优，但男女朋友可以做到全局最优，因为从局部最优搜索到全局最优需要不断考验对方的边界，而普通朋友看起来关系和谐，却是没法打破这一点的。</p><p>越陌生的朋友，越容易「在每一件事上都让彼此都舒服」。而恋人之间应该追求的是「总体上来看，我们在一起比不在一起，让彼此更舒服了」</p><p>比如你有个同学，这同学和你不算熟，你俩只有一个共同爱好，就是打dota。你们的生活除了游戏没有交集，只有晚上打dota的时候一起开黑，你们共度的每一段时光，都是彼此都开心的。你会发现，和这个同学一起玩的时候，「彼此都舒服」。至于他其他时候做什么，你一点都不关心。他爱干啥干啥，都不会令你感到不适。</p><p>男女朋友就是完全另一个系统了。</p><p>你认为，是否让彼此都舒服，是以「时间」来计算的。会有一个合理的「时间」，让男女双方都感到满意。这显然是一个过于简化的模型。</p><p>同样是两个小时，让女生陪男生看球，和让男生陪女生逛街，显然给双方带来的是截然不同的感受。因此时间并不是最本质的，做的事情才比较重要。</p><p>在成为恋人之后，你会发现，由于你们的生活被多多少少捆绑在一起，你们很多时候根本没有所谓「共赢」的选择。在某一件事情上，根本不可能让彼此「都舒服」。</p><p>就比如说看五月天演唱会。可能你女朋友是个五月天狂热粉，你对五月天毫无兴趣。这时候如果你陪你女朋友去看，你女朋友高兴，你不高兴。但是你不陪你女朋友去看，她觉得你作为男朋友竟然不喜欢她的爱豆，变成了你高兴她不高兴。也有可能，你不陪她，她就要和别的男生看，这时候你就更不高兴。或者说没有女生陪她看，你又担心她在这个比较复杂场合的安全，你又不高兴。再或者你说那咱们别去看五月天了，这时候变成了她不高兴。</p><p>你看，因为你们现在是男女朋友关系，而不是普通朋友了，就会出现很多别的想法，责任、义务、占有欲。这些想法就会让「彼此都舒服」成为一件不可能的事情。</p><p>而这些问题，根本不是所谓增加或者减少两个人「黏」在一起的时间可以解决的。这段时间在不在一起，都会引起其中一个人的不舒适。</p><p>男女朋友之间应该做的，是追求所谓「两个人加起来更开心」。</p><p>比如一件事，如果压根没这件事，你们俩心情不变，都是（0，0）。但是如果这件事女孩子做了，她很开心，你小不开心，变成了（10，-3）。这件事就是件可以做的事情。可这件事要是女孩子小开心，你大不开心，变成了（2，-20），那这件事就不应该做。</p><p>我之前说，喜欢一个人，是愿意和她做让彼此都开心的事情，但爱一个人，应该是愿意和她做让她开心可不让自己开心的事情。大概意思就是这样。</p><p>如果两个人都有这样的心态，那日积月累，你们每个人的开心值期望都应该是上升的，在一个地方让对方一下下，对方在未来就会用更好的方式弥补你。你陪我去看五月天，我就陪你去看邓紫棋。这就是所谓比较健康的恋情。</p><p>当然，并不是每一段恋情都是健康的。</p><p>如果有一个人的心态是「你应该事事站在我的立场考虑，只要我开心的事情就让我去做，我不开心的事情就不能做」，那另一个人的开心值很可能就会一直下降，直到他无法继续容忍。这个很好理解。</p><p>但是还有一种情况，即便有一个人的心态是「我应该事事站在你的立场考虑，只要你开心的事情我就愿意做，你不开心我就不做」，也会导致同样的结果。在模型上，他们是等价的。你什么时候看到过一段感情，只有一方玩命付出，努力牺牲，不断退让，最后还能修成正果的？</p><p>所以说，无论是男孩子还是女孩子，当你们感觉到另一半一直在让着自己，每件事都以自己开心为第一使命的时候，不要开心，这可能是分手的前奏。</p><p>然而，量化开心度并不是一件容易的事情。人们往往更容易感知到自己「是否开心」，而非「多开心」或者「多不开心」。更重要的是，人和人的价值观是有很大差异的。如果两个差别很大的人在一起，就会经常遇到这种取舍。动不动就是我很开心你很不开心。这样的感情就会导致两个人情绪波动太大，矛盾太多。而两个价值观很相似的人在一起，或许生活中大部分事情都是两个人都开心或者都不开心，他们几乎不太用做这种取舍。</p><p>理论固然有其可取之处，不过找到了对的人，这些就都不算是太大的问题了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;如果将交往看成一个找最优解问题，普通朋友能做到局部最优，但男女朋友可以做到全局最优，因为从局部最优搜索到全局最
      
    
    </summary>
    
    
      <category term="碎碎念" scheme="https://lolico.me/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Java知识小记</title>
    <link href="https://lolico.me/2022/03/22/Java%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/"/>
    <id>https://lolico.me/2022/03/22/Java%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/</id>
    <published>2022-03-22T14:57:05.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><p>1、一个字符的<code>String.length()</code>是多少？</p><p>Java中字符采用Unicode（UTF16）编码，即16位（2字节）一个单元，UTF16可以包含一个单元或两个单元，对于<code>U+0000-U+FFFF</code>范围内的字符采用2字节编码，大于<code>U+FFFF</code>的采用四字节编码。例如一些emoji或者生僻字，采用四字节编码及两单元，<code>String#length()</code>将返回2，如需返回字符数可使用<code>String#codePointCount(0,length)</code>。</p><p>2、SpringSecurity使用了什么模式？</p><p><code>构建者模式</code>、<code>责任链模式</code>。</p><p>3、SpringSecurity使用构建者模式最后构建的是一个什么？</p><p>是一个<code>Filter</code>、而且是<code>FilterChainProxy</code>，其内部包含多个<code>SecurityFilterChain</code>，根据请求匹配一个<code>SecurityFilterChain</code>并应用其中的<code>Filter</code>。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://s2.loli.net/2022/03/30/rGf8lqhwI5tpYA9.png" alt=""></div><div class="image-caption"></div></figure><p>4、简单说一下<code>Synchronized</code>和<code>AQS</code>有什么不同？</p><ul><li>前者是JVM层面实现、后者是语言层面实现。</li><li>前者根据不同锁实现方式不一样、后者是基于队列+CAS实现。</li><li>后者相比前者提供了更灵活的API、比如是否响应中断、超时时间设置、可绑定多个条件队列等等</li><li>前者只能是非公平锁、后者可实现公平锁，即先等待的线程先获取到锁。</li></ul><p>5、偏向锁、轻量级锁、重量级锁的升级过程简单说一下？</p><p>在不存在锁竞争时是偏向锁、此时只使用了一次CAS设置对象头中的偏向线程ID；存在资源竞争时、在全局安全点撤销偏向锁升级为轻量级锁，轻量级锁使用CAS来修改对象头中持有锁的线程ID；在轻量级锁CAS竞争锁失败一定次数（默认10）后升级为重量级锁；重量级锁基于操作系统的<code>Mutex Lock</code>实现。</p><p>6、三种锁是怎样确保线程安全的？</p><p>使用<code>Synchronized</code>关键字时，会在字节码中插入<code>monitorenter</code>和<code>monitorexit</code>指令，当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权，如果获取失败则根据锁类型自旋或者阻塞，从而确保线程安全。</p><p>7、AQS的原理简单说一下？内部使用了什么数据结构与设计模式？</p><p>AQS内部使用<code>双向循环队列+CAS</code>实现，使用了<code>模版方法模式</code>。</p><p>8、ThreadLocal存不存在内存泄漏问题?</p><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。但在使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法以便及时回收资源。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;1、一个字符的&lt;code&gt;String.length()&lt;/code&gt;是多少？&lt;/p&gt;&lt;p&gt;Java中字符采用
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Netty中Channel的生命周期</title>
    <link href="https://lolico.me/2022/03/06/Netty%E4%B8%ADChannel%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://lolico.me/2022/03/06/Netty%E4%B8%ADChannel%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-03-06T14:57:33.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="父EventLoopGroup中的Channel"><a href="#父EventLoopGroup中的Channel" class="headerlink" title="父EventLoopGroup中的Channel"></a>父EventLoopGroup中的Channel</h3><p>Registered -&gt; Bind -&gt; Active -&gt; [Read -&gt; Read Complete] -&gt; Close -&gt; Inactive -&gt; Unregistered</p><h3 id="子EventLoopGroup中的Channel"><a href="#子EventLoopGroup中的Channel" class="headerlink" title="子EventLoopGroup中的Channel"></a>子EventLoopGroup中的Channel</h3><p>Registered -&gt; Active -&gt; [(Read/Write -&gt; Read Complete/Flush)、Event Triggered、Exception Caught] -&gt; Inactive -&gt;Unregistered</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Registered -&gt; Connect -&gt; Active(Lazy Active) -&gt; [(Read/Write -&gt; Read Complete/Flush)、Event Triggered、Exception Caught、Disconnect] -&gt; Close -&gt; Inactive -&gt; Unregistered</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;headerlink&quot; title=&quot;服务端&quot;
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Netty" scheme="https://lolico.me/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>AOP详解</title>
    <link href="https://lolico.me/2020/07/22/AOP%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lolico.me/2020/07/22/AOP%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-07-22T15:01:12.000Z</published>
    <updated>2022-04-09T14:18:50.400Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p>AOP（<code>Aspect-oriented Programming</code>），称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如权限控制、事务管理、日志、缓存等等。</p><p>AOP代理主要分为<code>静态代理</code>和<code>动态代理</code>，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。静态代理一般在编译期或者加载期实现，动态代理是运行期实现。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>AspectJ的静态代理，不是基于代理的。它使用修改字节码的技术将通知织入到目标类，所以，在运行时的类已经不是原本的那个类，是经过修改的了。通常来说，你写的AOP相关的代码，和对象的结合过程叫做织入(weave)。AspectJ的织入过程，有可能发生在三个阶段：</p><ul><li>编译时织入(Compile-time weaving) 使用AspectJ的编译器ajc，在项目编译的阶段就将代码织入目标类</li><li>编译后织入(Post-compile weaving) 使用AspectJ的编译器ajc，向javac编译出来的的class织入代码</li><li>加载时织入(Load-time weaving) 使用特定的类加载器在类加载时期修改类字节码后加载进JVM</li></ul><p>从上面可以看出，在程序的运行阶段，我们使用的类都是已经织入了通知代码的（并不会创建出多余的对象），而不像Spring AOP，需要在运行的时候去生成动态代理或者生成类。所以说，AspectJ的运行效率相比动态代理生成的类要高一点。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理则不会修改字节码，而是在内存中生成一个代理对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。所以动态代理是在方法层级上进行代理，代理细度上不如静态代理。</p><h2 id="生成AOP代理的入口"><a href="#生成AOP代理的入口" class="headerlink" title="生成AOP代理的入口"></a>生成AOP代理的入口</h2><p>Spring所有的代理<code>AopProxy</code>的创建最后都是<code>ProxyCreatorSupport#createAopProxy</code>这个方法，而这个方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">activate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然它又是调用了<code>AopProxyFactory#createAopProxy</code>方法，它的唯一实现为<code>DefaultAopProxyFactory</code>。它做了一个简单的逻辑判断：若实现类接口，使用<code>JdkDynamicAopProxy</code>去创建，否则使用<code>ObjenesisCglibAopProxy</code>。</p><p>最终拿到<code>AopProxy</code>后，调用<code>AopProxy#getProxy()</code>就可以拿到代理对象，从而进行相应的工作了。</p><p>我们基本有一共共识就是：默认情况下，若我们实现了接口，就实用JDK动态代理，若没有就实用CGLIB。那么接下来，就来看看代理对象的创建、执行的具体过程是如何的。</p><h2 id="AopProxy"><a href="#AopProxy" class="headerlink" title="AopProxy"></a>AopProxy</h2><p>它是一个AOP代理的抽象接口。提供了两个方法，让我们可以获取对应 配置的AOP对象的代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line"><span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现类只有三个：</p><ul><li><code>JdkDynamicAopProxy</code> 基于jdk动态代理生成代理对象</li><li><code>CglibAopProxy</code> 基于cglib生成一个代理子类</li><li><code>ObjenesisCglibAopProxy</code> 基于Objenesis扩展<code>CglibAopProxy</code>，提供不调用类的构造函数来创建代理对象。</li></ul><h3 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a>JdkDynamicAopProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5531744639992436476L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(JdkDynamicAopProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里就保存这个AOP代理所有的配置信息，包括所有的增强器等等</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line">    <span class="comment">// 用于记录代理接口中是否定义了equals和hashCode方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> equalsDefined;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hashCodeDefined;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">Assert.notNull(config, <span class="string">"AdvisedSupport must not be null"</span>);</span><br><span class="line">        <span class="comment">// 至少需要一个增强器和目标实例才行</span></span><br><span class="line"><span class="keyword">if</span> (config.getAdvisors().length == <span class="number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"No advisors and no TargetSource specified"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.advised = config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Creating JDK dynamic proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 这部很重要，就是去找接口 我们看到最终代理的接口就是这里返回的所有接口们（除了我们自己的接口，还有Spring默认的一些接口）  大致过程如下：</span></span><br><span class="line"><span class="comment">//1、获取目标对象自己实现的接口(最终肯定都会被代理的)</span></span><br><span class="line"><span class="comment">//2、是否添加`SpringProxy`这个接口：目标对象实现对就不添加了，没实现过就添加</span></span><br><span class="line"><span class="comment">//3、是否新增`Adviced`接口，注意不是Advice通知接口。 实现过就不实现了，没实现过并且advised.isOpaque()为false就添加（默认会添加的）</span></span><br><span class="line"><span class="comment">//4、是否新增DecoratingProxy接口。传入的第二个参数decoratingProxy为true，并且没实现过就添加（显然这里，首次进来是会添加的）</span></span><br><span class="line"><span class="comment">//5、代理类的接口一共是目标对象的接口+上面三个接口SpringProxy、Advised、DecoratingProxy（SpringProxy是个标记接口而已，其余的接口都有对应的方法的）</span></span><br><span class="line"><span class="comment">//DecoratingProxy 这个接口Spring4.3后才提供</span></span><br><span class="line">Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">        <span class="comment">// 创建jdk动态代理对象，InvocationHandler传的this</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找找看接口里有没有自己定义equals方法和hashCode方法，然后标记一下</span></span><br><span class="line"><span class="comment">// 注意此处用的是getDeclaredMethods，只会找当前类中的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findDefinedEqualsAndHashCodeMethods</span><span class="params">(Class&lt;?&gt;[] proxiedInterfaces)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; proxiedInterface : proxiedInterfaces) &#123;</span><br><span class="line">Method[] methods = proxiedInterface.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"><span class="keyword">if</span> (AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line"><span class="keyword">this</span>.equalsDefined = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line"><span class="keyword">this</span>.hashCodeDefined = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.equalsDefined &amp;&amp; <span class="keyword">this</span>.hashCodeDefined) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line"><span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line"><span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line"><span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line"><span class="keyword">return</span> hashCode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line"><span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line"><span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line"><span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line"><span class="comment">// in case it comes from a pool.</span></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line"><span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line"><span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line"><span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line">MethodInvocation invocation =</span><br><span class="line"><span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Massage return value if necessary.</span></span><br><span class="line">Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">returnType != Object<span class="class">.<span class="keyword">class</span> &amp;&amp; <span class="title">returnType</span>.<span class="title">isInstance</span>(<span class="title">proxy</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">!<span class="title">RawTargetAccess</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line"><span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line"><span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line"><span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">retVal = proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line"><span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line"><span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">targetSource.releaseTarget(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line"><span class="comment">// Restore old proxy.</span></span><br><span class="line">AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(@Nullable Object other)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (other == <span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (other == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JdkDynamicAopProxy otherProxy;</span><br><span class="line"><span class="keyword">if</span> (other <span class="keyword">instanceof</span> JdkDynamicAopProxy) &#123;</span><br><span class="line">otherProxy = (JdkDynamicAopProxy) other;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Proxy.isProxyClass(other.getClass())) &#123;</span><br><span class="line">InvocationHandler ih = Proxy.getInvocationHandler(other);</span><br><span class="line"><span class="keyword">if</span> (!(ih <span class="keyword">instanceof</span> JdkDynamicAopProxy)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">otherProxy = (JdkDynamicAopProxy) ih;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Not a valid comparison...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we get here, otherProxy is the other AopProxy.</span></span><br><span class="line"><span class="keyword">return</span> AopProxyUtils.equalsInProxy(<span class="keyword">this</span>.advised, otherProxy.advised);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> JdkDynamicAopProxy<span class="class">.<span class="keyword">class</span>.<span class="title">hashCode</span>() * 13 + <span class="title">this</span>.<span class="title">advised</span>.<span class="title">getTargetSource</span>().<span class="title">hashCode</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CglibAopProxy"><a href="#CglibAopProxy" class="headerlink" title="CglibAopProxy"></a>CglibAopProxy</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;什么是AOP？&quot;&gt;&lt;a href=&quot;#什么是AOP？&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://lolico.me/tags/Spring/"/>
    
      <category term="AOP" scheme="https://lolico.me/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring中ControllerAdvice失效的几种场景</title>
    <link href="https://lolico.me/2020/07/07/Spring%E4%B8%ADControllerAdvice%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF/"/>
    <id>https://lolico.me/2020/07/07/Spring%E4%B8%ADControllerAdvice%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF/</id>
    <published>2020-07-07T15:01:12.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><ol><li>异步调用的方法中抛出异常</li><li>Around切面在调用ProceedingJoinPoint#proceed时catch并且处理了异常</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;ol&gt;&lt;li&gt;异步调用的方法中抛出异常&lt;/li&gt;&lt;li&gt;Around切面在调用ProceedingJoinPoin
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://lolico.me/tags/Spring/"/>
    
      <category term="Web" scheme="https://lolico.me/tags/Web/"/>
    
      <category term="SpringBoot" scheme="https://lolico.me/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Stream消息队列在SpringBoot中的实践与踩坑</title>
    <link href="https://lolico.me/2020/06/28/Stream%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9C%A8SpringBoot%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/"/>
    <id>https://lolico.me/2020/06/28/Stream%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9C%A8SpringBoot%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%B8%A9%E5%9D%91/</id>
    <published>2020-06-28T13:54:57.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Redis5</code>新增了一个<code>Stream</code>的数据类型，这个类型作为消息队列来使用时弥补了<code>List</code>和<code>Pub/Sub</code>的不足并且提供了更强大的功能，比如<code>ack</code>机制以及消费者组等概念，在有轻量消息队列使用需求时，使用这个新类型那是再好不过了。对于这个类型，在这里就不赘述了，想了解的话可以看一下这篇<a href="http://www.hellokang.net/redis/stream.html#_1-%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">文章</a>，在这里，我们就具体来讲一下在<code>SpringBoot</code>中的实践与踩坑。</p><p>注意，<code>SpringBoot</code>版本需要大于2.2（即<code>spring-data-redis</code>需要大于2.2）。</p><h2 id="新API和类"><a href="#新API和类" class="headerlink" title="新API和类"></a>新API和类</h2><p>在开始正文之前，我们先简单了解一下在2.2引入的和Stream操作相关的方法和类。</p><h3 id="消息和消息ID的对象"><a href="#消息和消息ID的对象" class="headerlink" title="消息和消息ID的对象"></a>消息和消息ID的对象</h3><p>消息（或者称为记录）和消息ID在Spring-Data-Redis中使用<code>Record</code>和<code>RecordId</code>来表示。</p><p>一个<code>Record</code>包含三部分内容：</p><ul><li><code>stream</code>表示这个消息要发往那个Stream，也就是Stream的key</li><li><code>recordId</code>表示这个消息的ID，一般Redis服务器自动生成，也可以指定</li><li><code>value</code>表示消息内容</li></ul><p>SpringBoot为我们提供了五种消息类型的抽象：<code>MapRecord</code>、<code>ObjectRecord</code>、<code>ByteRecord</code>、<code>ByteBufferRecord</code>、<code>StringRecord</code>，以及一个消息ID类型：<code>RecordId</code>。</p><blockquote><p>这里另外说一下：其实除开<code>ObjectRecord</code>，其他几个<code>Record</code>都是通过继承<code>MapRecord</code>扩展而来的。<code>StringRecord</code>中的消息内容也并非仅仅是一个字符串，而是一个键值都为字符串类型的<code>Map</code>（<code>ByteRecord</code>、<code>ByteBufferRecord</code>同理）。而<code>ObjectRecord</code>最后也会使用<code>HashMapper</code>转换成<code>MapRecord</code>。为什么最后都是操作<code>Map</code>类型？这是因为Stream中的内容是以多个<code>key-value</code>这种键值对的形式存储的。</p></blockquote><p>那么我们怎样去创建一个消息对象呢？</p><p>一般来说我们使用前两个消息类型比较多，所以Spring-Data-Redis很贴心的在<code>Record</code>这个顶级接口中提供了两个静态方法用于直接构造<code>MapRecord</code>和<code>ObjectRecord</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;S, K, V&gt; <span class="function">MapRecord&lt;S, K, V&gt; <span class="title">of</span><span class="params">(Map&lt;K, V&gt; map)</span></span></span><br><span class="line"><span class="function">    Assert.<span class="title">notNull</span><span class="params">(map, <span class="string">"Map must not be null!"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> StreamRecords.mapBacked(map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;S, V&gt; <span class="function">ObjectRecord&lt;S, V&gt; <span class="title">of</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(value, <span class="string">"Value must not be null!"</span>);</span><br><span class="line">    <span class="keyword">return</span> StreamRecords.objectBacked(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这两个方法实际上是调用了<code>StreamRecords</code>中提供的静态方法来创建，<code>StreamRecords</code>这个类提供了下面这些方法用于创建五种<code>Record</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ByteRecord <span class="title">rawBytes</span><span class="params">(Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; raw)</span> </span></span><br><span class="line"><span class="function">ByteBufferRecord <span class="title">rawBuffer</span><span class="params">(Map&lt;ByteBuffer, ByteBuffer&gt; raw)</span> </span></span><br><span class="line"><span class="function">StringRecord <span class="title">string</span><span class="params">(Map&lt;String, String&gt; raw)</span></span></span><br><span class="line"><span class="function">&lt;S, K, V&gt; MapRecord&lt;S, K, V&gt; <span class="title">mapBacked</span><span class="params">(Map&lt;K, V&gt; map)</span></span></span><br><span class="line"><span class="function">&lt;S, V&gt; ObjectRecord&lt;S, V&gt; <span class="title">objectBacked</span><span class="params">(V value)</span></span></span><br><span class="line"><span class="function">RecordBuilder&lt;?&gt; <span class="title">newRecord</span><span class="params">()</span>  <span class="comment">// 通过builder方式创建</span></span></span><br></pre></td></tr></table></figure><p>当然，我们还可以通过使用某个具体的<code>Record</code>类型的<code>create</code>静态方法来创建，下面是几个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String streamKey = <span class="string">"channel:stream:key1"</span>;<span class="comment">//stream key</span></span><br><span class="line">MailInfo mailInfo = <span class="keyword">new</span> MailInfo(<span class="string">"554205726@qq.com"</span>, <span class="string">"sendmail"</span>);<span class="comment">//定义一个Object类型的消息内容</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">    put(<span class="string">"receiver"</span>, <span class="string">"534619360@qq.com"</span>);</span><br><span class="line">&#125;&#125;; <span class="comment">//定义一个Map类型的消息内容</span></span><br><span class="line">Record.of(mailInfo).withStreamKey(streamKey);</span><br><span class="line">Record.of(map).withStreamKey(streamKey).withId(RecordId.of(<span class="string">"123"</span>));<span class="comment">//指定id</span></span><br><span class="line">StreamRecords.objectBacked(mailInfo).withStreamKey(streamKey);</span><br><span class="line">StreamRecords.mapBacked(map).withStreamKey(streamKey).withId(RecordId.autoGenerate());<span class="comment">//指定id</span></span><br><span class="line">ObjectRecord.create(streamKey, mailInfo); <span class="comment">//使用ObjectRecord的create静态方法创建</span></span><br></pre></td></tr></table></figure><p>如果我们不通过<code>withId</code>方法显示调用去指定<code>id</code>，那么默认的情况下就是使用<code>RecordId.autoGenerate()</code>自动生成。还有一个需要注意的地方就是在使用<code>StreamRecords</code>的方法来构建<code>Record</code>时一定要记住用<code>withStreamKey</code>方法来指定<code>Stream Key</code>。</p><p>不管是消息或是消息ID，这些类基本都提供了扁平化的api来构造，使用起来还是很简单的。那么在构造了一个<code>Record</code>后怎么将其持久化到Redis的Stream类型中呢？</p><h3 id="向Stream添加消息（Record"><a href="#向Stream添加消息（Record" class="headerlink" title="向Stream添加消息（Record)"></a>向Stream添加消息（Record)</h3><p>使用<code>RedisTemplate</code>操作<code>Stream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String streamKey = <span class="string">"channel:stream:key1"</span>;<span class="comment">//stream key</span></span><br><span class="line">MailInfo mailInfo = <span class="keyword">new</span> MailInfo(<span class="string">"554205726@qq.com"</span>, <span class="string">"sendmail"</span>);</span><br><span class="line"></span><br><span class="line">ObjectRecord&lt;String, MailInfo&gt; record = ObjectRecord.create(streamKey, mailInfo);</span><br><span class="line"></span><br><span class="line">RecordId id = record.getId(); <span class="comment">//构造Record时使用的RecordId</span></span><br><span class="line">RecordId recordId = redisTemplate.opsForStream().add(record); <span class="comment">//返回的RecordId</span></span><br><span class="line"></span><br><span class="line">id.getTimestamp(); <span class="comment">//null</span></span><br><span class="line">id.getSequence(); <span class="comment">//null</span></span><br><span class="line">id.shouldBeAutoGenerated(); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">recordId.getTimestamp(); <span class="comment">//not null</span></span><br><span class="line">recordId.getSequence(); <span class="comment">//not null</span></span><br><span class="line">recordId.shouldBeAutoGenerated(); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>使用<code>add</code>方法来添加记录，该方法执行成功后返回添加的记录的<code>id</code>信息。注意下面的结果，这里有两个问题需要注意：</p><ol><li><p>为什么我们构造<code>Record</code>时使用的<code>RecordId</code>和添加记录返回的<code>RecordId</code>不同？</p><p>这个问题很好理解，因为构造<code>Record</code>时不指定<code>id</code>时虽然是自动生成，但是这个自动生成<strong>并不是</strong>在构造时就自动生成好了的，而是在执行Redis命令持久化时Redis服务器来自动生成的，所以前者在获取时间戳和序号的时返回<code>null</code>。</p></li><li><p>为什么添加记录返回的<code>RecordId</code>调用<code>shouldBeAutoGenerated</code>方法返回<code>false</code>呢，不是自动生成了吗？</p><p>其实也很好理解，因为在持久化一条Stream的记录时，我们可以指定<code>id</code>，也可以选择让Redis来自动生成，那么这也就导致<code>add</code>方法执行成功获取到Redis返回的<code>id</code>信息后在构造<code>RecordId</code>时<strong>并不知道</strong>返回的这个<code>id</code>是我们之前指定的还是Redis自动生成的，所以说前者返回<code>true</code>，后者返回<code>false</code>并不难理解。</p></li></ol><blockquote><p>说到这里，其实你去看一下<code>Record</code>构造时默认自动生成<code>id</code>是如何做到的就很好理解了。在这里稍微提一下：在构造<code>Record</code>时默认使用<code>RecordId.autoGenerate()</code>作为<code>RecordId</code>，而这个方法返回了一个匿名对象，这个匿名对象重写了上面那三个方法，前两个方法重写直接返回<code>null</code>，后者也就是<code>shouldBeAutoGenerated</code>方法返回<code>true</code>。</p></blockquote><h2 id="实现消息队列"><a href="#实现消息队列" class="headerlink" title="实现消息队列"></a>实现消息队列</h2><p>在基本了解了<code>SpringBoot2.2</code>新增的几个Stream操作api和相关类之后，也就到了我们Stream实现消息队列的实践部分了。为了方便，下面我会以发送邮件为例来讲一下如何使用Strean来实现消息队列。</p><p>为了方便后续的讲解，先构造一个简单的邮件信息类作为我们的消息内容：</p><figure class="highlight java"><figcaption><span>MailInfo.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造StreamMessageListenerContainer"><a href="#构造StreamMessageListenerContainer" class="headerlink" title="构造StreamMessageListenerContainer"></a>构造StreamMessageListenerContainer</h3><p>在使用<code>Pub/Sub</code>模式时，我们都是先创建一个<code>RedisMessageListenerContainer</code>容器，向这个容器注册监听器然后在<code>onMessage</code>方法中处理业务逻辑即可。那么使用<code>Stream</code>类型的话有没有提供一个类似的容器呢？答案是肯定的。在<code>SpringBoot2.2</code>提供了<code>StreamMessageListenerContainer</code>这个Stream类型专有的消息监听容器，而唯一的实现也就是<code>DefaultStreamMessageListenerContainer</code>。</p><p><code>StreamMessageListenerContainer</code>的构造函数相比<code>RedisMessageListenerContainer</code>多了一个<code>StreamMessageListenerContainerOptions</code>，这个对象是使用<code>builder</code>方式来创建的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StreamMessageListenerContainerOptions&lt;String, ObjectRecord&lt;String, MailInfo&gt;&gt; options =</span><br><span class="line">        StreamMessageListenerContainerOptions.builder()</span><br><span class="line">                .batchSize(<span class="number">100</span>) <span class="comment">//一批次拉取的最大count数</span></span><br><span class="line">                .executor(executor)  <span class="comment">//线程池</span></span><br><span class="line">                .pollTimeout(Duration.ZERO) <span class="comment">//阻塞式轮询</span></span><br><span class="line">                .targetType(MailInfo<span class="class">.<span class="keyword">class</span>) //目标类型（消息内容的类型）</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line">StreamMessageListenerContainer&lt;String, ObjectRecord&lt;String, MailInfo&gt;&gt; container =</span><br><span class="line">    StreamMessageListenerContainer.create(redisConnectionFactory, options);</span><br></pre></td></tr></table></figure><p>在构造<code>StreamMessageListenerContainerOptions</code>时最关键的就是<code>targetType</code>、<code>objectMapper</code>以及设置序列化器这几个方法，这些参数的设置会直接影响到后续接收到消息后能否反序列化为java对象！由于这部分内容涉及源码过多，在后面一部分我们再针对这几个方法进行详细的探查。</p><p>在构造完<code>StreamMessageListenerContainer</code>之后，现在该怎么注册消息监听器呢？我们接着往下看。</p><h3 id="注册StreamListener"><a href="#注册StreamListener" class="headerlink" title="注册StreamListener"></a>注册StreamListener</h3><p>在Pub/Sub模式中我们使用<code>addMessageListener(MessageListener, Topic)</code>方法添加一个<code>MessageListener</code>到指定的<code>Topic</code>，那么在使用Stream消息的监听容器时，我们是使用<code>receive</code>方法。</p><p><code>Spring-data-redis</code>提供了三个方法用于注册<code>StreamListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Subscription <span class="title">receive</span><span class="params">(StreamOffset&lt;K&gt; streamOffset, StreamListener&lt;K, V&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(StreamReadRequest.builder(streamOffset).build(), listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Subscription <span class="title">receive</span><span class="params">(Consumer consumer, StreamOffset&lt;K&gt; streamOffset, StreamListener&lt;K, V&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(StreamReadRequest.builder(streamOffset).consumer(consumer).autoAcknowledge(<span class="keyword">false</span>).build(), listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Subscription <span class="title">receiveAutoAck</span><span class="params">(Consumer consumer, StreamOffset&lt;K&gt; streamOffset, StreamListener&lt;K, V&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(StreamReadRequest.builder(streamOffset).consumer(consumer).autoAcknowledge(<span class="keyword">true</span>).build(), listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你发现你哪里<code>receive</code>方法和我的不太一样？那么你使用的版本应该是2.2，这个版本的问题比较多，比如上面这个地方，使用第二个方法注册<code>StreamListener</code>，在消息被消费之后会自动ack，因为<code>ConsumerStreamReadRequestBuilder</code>的<code>autoAck</code>属性默认就是<code>true</code>（除非使用第一个方法指定<code>StreamReadRequest</code>），这个问题在2.3修复了，感兴趣可以去看看这部分源码，修补提交<a href="https://github.com/spring-projects/spring-data-redis/commit/fccaeb23e99423b6ecca5dd023975a78c15c62ed#diff-879e58efc888ebee209566792c347c00" target="_blank" rel="noopener">在这里</a>。</p><blockquote><p>我个人最初就是使用的SpringBoot2.2.2，使用过程中发现<a href="https://jira.spring.io/projects/DATAREDIS/issues/DATAREDIS-1043?filter=allopenissues" target="_blank" rel="noopener">问题真的有点很多</a>。比如还有一处序列化器泛型类型错误导致<code>StreamMessageListenerContainerOptions</code>构造混乱的问题【<a href="https://github.com/spring-projects/spring-data-redis/commit/df720bde8fa3ccd811d010471440e07ce10b796c#diff-879e58efc888ebee209566792c347c00" target="_blank" rel="noopener">修补提交</a>】，所以说如果你想尝鲜，那么强烈建议使用<code>SpringBoot</code>最新发布的版本。</p></blockquote><h4 id="Consumer和StreamOffset"><a href="#Consumer和StreamOffset" class="headerlink" title="Consumer和StreamOffset"></a>Consumer和StreamOffset</h4><p>可以看到<code>receive</code>方法另外还需要<code>Consumer</code>和<code>StreamOffset</code>两个参数，</p><p><strong>Consumer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer.from(<span class="string">"group name"</span>, <span class="string">"consumer name"</span>)</span><br></pre></td></tr></table></figure><p><code>Consumer</code>表示消费者组中的某个消费者，这个东西只会在消费者组模式中用到。我们一般通过上面这种方式来创建，第一个参数表示消费者组，第二个参数表示消费者。</p><p><strong>StreamOffset</strong></p><p><code>StreamOffset</code>用于表示在某个Stream上的偏移量，它包含两部分内容，一个是stream的<code>key</code>，另一个是<code>ReadOffset</code>用于表示读取偏移量。前者应该不需要过多的解释，那么<code>ReadOffset</code>这个读取偏移量是干嘛用的呢？</p><p>要搞清楚<code>ReadOffset</code>，我们首先要知道Stream中偏移量的含义，在Stream中偏移量既可以表示消费记录时的偏移量，又可以表示消费者组在Stream上的偏移量。还记得Redis中我们怎么读取Stream中的记录吗？</p><p>通过<code>xread</code>命令也就是非消费者组模式直接读取，或者使用<code>xreadgroup</code>命令在消费者组中命令一个消费者去消费一条记录，这个时候，我们可以通过<code>0</code>、<code>&gt;</code>、<code>$</code>分别表示第一条记录、最后一次未被消费的记录和最新一条记录，这也就是<code>ReadOffset</code>的用途之一：<strong>用于表示直接读取或消费者组中消费者读取记录时的偏移量</strong>。</p><p>那么还有另外的用途吗？</p><p>当然了，还记得怎样创建消费者组吗？一般我们使用<code>xgroup create</code>命令创建一个消费者组时可以选择从Stream的第一条消息开始，或者Stream的中间某个记录开始，又或者从Stream的最新一条记录开始。也就分别代表了<code>0</code>、<code>$</code>。这也就是<code>ReadOffset</code>的用途之二：<strong>用于表示创建消费者组时该消费者组在Stream上的偏移量</strong>。</p><p>理解<code>ReadOffset</code>最快最简单的方法就是在Redis-cli中用Redis命令操作一番。这其中还有一些值得注意的问题，比如创建消费者组时不能使用<code>&gt;</code>表示最后一次未被消费的记录；比如<code>0</code>表示从第一条开始并且包括第一条；<code>$</code>表示从最新一条开始但并不是指当前Stream的最后一条记录，所以使用<code>$</code>时最新一条也就是表示下一个<code>xadd</code>添加的那一条记录，所以说<code>$</code>在非消费者组模式的阻塞读取下才有意义！</p><h3 id="实现StreamListener"><a href="#实现StreamListener" class="headerlink" title="实现StreamListener"></a>实现StreamListener</h3><p>同样的用Pub/Sub来类比，在Pub/Sub模式下我们实现的消息监听器是一般是<code>MessageListener</code>或者使用<code>MessageListenerAdapter</code>反射调用处理方法，在Strean消息队列的实现中必然也需要一个监听器用于处理真正的业务逻辑，这个类目前只有一个，也就是<code>StreamListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMessageListener</span> <span class="keyword">implements</span> <span class="title">StreamListener</span>&lt;<span class="title">String</span>, <span class="title">ObjectRecord</span>&lt;<span class="title">String</span>, <span class="title">MailInfo</span>&gt;&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(StreamMessageListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamMessageListener</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(ObjectRecord&lt;String, MailInfo&gt; message)</span> </span>&#123;</span><br><span class="line">        RecordId id = message.getId();</span><br><span class="line">        MailInfo messageValue = message.getValue();</span><br><span class="line">        logger.info(<span class="string">"消费stream:&#123;&#125;中的信息:&#123;&#125;, 消息id:&#123;&#125;"</span>, message.getStream(), messageValue, id);</span><br><span class="line">        <span class="comment">// 发邮件...</span></span><br><span class="line">        stringRedisTemplate.opsForStream().acknowledge(MAIL_GROUP, message); <span class="comment">//手动ack</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StreamListener</code>和<code>MessageListener</code>差不多，只需要实现<code>onMessage</code>方法，只不过多了个泛型参数罢了。在实现消息监听器后也就可以使用<code>receive</code>方法进行注册了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">container.receive(Consumer.from(MAIL_GROUP, <span class="string">"consumer-1"</span>),</span><br><span class="line">        StreamOffset.create(MAIL_CHANNEL, ReadOffset.lastConsumed()),</span><br><span class="line">        <span class="keyword">new</span> StreamMessageListener(stringRedisTemplate));</span><br></pre></td></tr></table></figure><p>注册完成之后启动<code>StreamMessageListenerContainer</code>容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.start();</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamConsumerRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_CHANNEL = <span class="string">"channel:stream:mail"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_GROUP = <span class="string">"group:mail"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolTaskExecutor executor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StreamMessageListenerContainer&lt;String, ObjectRecord&lt;String, MailInfo&gt;&gt; container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamConsumerRunner</span><span class="params">(ThreadPoolTaskExecutor executor, RedisConnectionFactory redisConnectionFactory, StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="keyword">this</span>.redisConnectionFactory = redisConnectionFactory;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        StreamMessageListenerContainerOptions&lt;String, ObjectRecord&lt;String, MailInfo&gt;&gt; options =</span><br><span class="line">                StreamMessageListenerContainerOptions.builder()</span><br><span class="line">                        .batchSize(<span class="number">10</span>)</span><br><span class="line">                        .executor(executor)</span><br><span class="line">                        .pollTimeout(Duration.ZERO)</span><br><span class="line">                        .targetType(MailInfo<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                        .<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line">        StreamMessageListenerContainer&lt;String, ObjectRecord&lt;String, MailInfo&gt;&gt; container =</span><br><span class="line">                StreamMessageListenerContainer.create(redisConnectionFactory, options);</span><br><span class="line"></span><br><span class="line">        prepareChannelAndGroup(stringRedisTemplate.opsForStream(), MAIL_CHANNEL, MAIL_GROUP);</span><br><span class="line"></span><br><span class="line">        container.receive(Consumer.from(MAIL_GROUP, <span class="string">"consumer-1"</span>),</span><br><span class="line">                StreamOffset.create(MAIL_CHANNEL, ReadOffset.lastConsumed()),</span><br><span class="line">                <span class="keyword">new</span> StreamMessageListener(stringRedisTemplate));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">        <span class="keyword">this</span>.container.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareChannelAndGroup</span><span class="params">(StreamOperations&lt;String, ?, ?&gt; ops, String channel, String group)</span> </span>&#123;</span><br><span class="line">        String status = <span class="string">"OK"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StreamInfo.XInfoGroups groups = ops.groups(channel);</span><br><span class="line">            <span class="keyword">if</span> (groups.stream().noneMatch(xInfoGroup -&gt; group.equals(xInfoGroup.groupName()))) &#123;</span><br><span class="line">                status = ops.createGroup(channel, group);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            RecordId initialRecord = ops.add(ObjectRecord.create(channel, <span class="string">"Initial Record"</span>));</span><br><span class="line">            Assert.notNull(initialRecord, <span class="string">"Cannot initialize stream with key '"</span> + channel + <span class="string">"'"</span>);</span><br><span class="line">            status = ops.createGroup(channel, ReadOffset.from(initialRecord), group);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Assert.isTrue(<span class="string">"OK"</span>.equals(status), <span class="string">"Cannot create group with name '"</span> + group + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMessageListener</span> <span class="keyword">implements</span> <span class="title">StreamListener</span>&lt;<span class="title">String</span>, <span class="title">ObjectRecord</span>&lt;<span class="title">String</span>, <span class="title">MailInfo</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(StreamMessageListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StreamMessageListener</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(ObjectRecord&lt;String, MailInfo&gt; message)</span> </span>&#123;</span><br><span class="line">            RecordId id = message.getId();</span><br><span class="line">            MailInfo messageValue = message.getValue();</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">"消费stream:&#123;&#125;中的信息:&#123;&#125;, 消息id:&#123;&#125;"</span>, message.getStream(), messageValue, id);</span><br><span class="line"></span><br><span class="line">            stringRedisTemplate.opsForStream().acknowledge(MAIL_GROUP, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>prepareChannelAndGroup</code>方法，在初始化容器时，如果key对应的stream或者group不存在时会抛出异常，所以我们需要提前检查并且初始化。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>添加一个测试接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/sendMail"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;RecordId&gt; <span class="title">sendMail</span><span class="params">(String receiver, String description)</span> </span>&#123;</span><br><span class="line">    MailInfo mailInfo = <span class="keyword">new</span> MailInfo(receiver, description);</span><br><span class="line">    ObjectRecord&lt;String, MailInfo&gt; record = Record.of(mailInfo).withStreamKey(channel);</span><br><span class="line">    RecordId recordId = redisTemplate.opsForStream().add(record);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(recordId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问进行测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-06-28 19:26:17.870  INFO 21900 --- [         task-1] reamConsumerRunner$StreamMessageListener : 消费stream:channel:stream:mail中的信息:MailInfo(receiver&#x3D;534619360@qq.com, description&#x3D;发送邮件), 消息id:1593343576237-0</span><br></pre></td></tr></table></figure><p>控制台输出日志，如果在redis-cli中使用<code>xpending</code>命令检查ack信息会发现也是0，因为我们虽然使用<code>receive</code>方法注册，但是在<code>onMessage</code>中手动提交了确认，当然，你也可以使用<code>receiveAutoAck</code>方法添加。</p><h2 id="实践中踩到的坑"><a href="#实践中踩到的坑" class="headerlink" title="实践中踩到的坑"></a>实践中踩到的坑</h2><h3 id="自动ack和泛型类型错误"><a href="#自动ack和泛型类型错误" class="headerlink" title="自动ack和泛型类型错误"></a>自动ack和泛型类型错误</h3><p>这两个问题在前面已经提到了并且在2.3已经修复，这里不多说。还是那句话，如果想尝鲜，那么强烈推荐使用SpringBoot最新发布的版本。</p><h3 id="RedisTemplate序列化器使用错误导致容器无法反序列化"><a href="#RedisTemplate序列化器使用错误导致容器无法反序列化" class="headerlink" title="RedisTemplate序列化器使用错误导致容器无法反序列化"></a>RedisTemplate序列化器使用错误导致容器无法反序列化</h3><p><code>RedisTemplate</code>的hashvalue的序列化器最初使用的json序列化器，导致容器监听到新消息反序列化时抛出异常：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Value must not be null!</span><br><span class="line">    at org.springframework.util.Assert.notNull(Assert.java:198)</span><br><span class="line">    at org.springframework.data.redis.connection.stream.Record.of(Record.java:81)</span><br><span class="line">    at org.springframework.data.redis.connection.stream.MapRecord.toObjectRecord(MapRecord.java:147)</span><br><span class="line">    at org.springframework.data.redis.core.StreamObjectMapper.toObjectRecord(StreamObjectMapper.java:132)</span><br><span class="line">    at org.springframework.data.redis.core.StreamObjectMapper.map(StreamObjectMapper.java:158)</span><br><span class="line">    at org.springframework.data.redis.core.StreamOperations.read(StreamOperations.java:458)</span><br><span class="line">    at org.springframework.data.redis.stream.DefaultStreamMessageListenerContainer.lambda$getReadFunction$2(DefaultStreamMessageListenerContainer.java:232)</span><br><span class="line">    at org.springframework.data.redis.stream.StreamPollTask.doLoop(StreamPollTask.java:138)</span><br><span class="line">    at org.springframework.data.redis.stream.StreamPollTask.run(StreamPollTask.java:123)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>这是为什么呢？我们知道Redis中Stream中存的是键值对并且<code>DefaultStreamOperations</code>中操作的都是<code>byte[]</code>，也就是说我们虽然添加的是<code>ObjectRecord</code>，但是会先转换成<code>MapRecord</code>，然后再被转换成<code>ByteRecord</code>，最后进行序列化。来看一下<code>add</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RecordId <span class="title">add</span><span class="params">(Record&lt;K, ?&gt; record)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(record, <span class="string">"Record must not be null"</span>);</span><br><span class="line">    MapRecord&lt;K, HK, HV&gt; input = StreamObjectMapper.toMapRecord(<span class="keyword">this</span>, record); <span class="comment">//转换成MapRecord</span></span><br><span class="line">    ByteRecord binaryRecord = input.serialize(keySerializer(), hashKeySerializer(), hashValueSerializer()); <span class="comment">//再使用序列化器转换成ByteRecord</span></span><br><span class="line">    <span class="keyword">return</span> execute(connection -&gt; connection.xAdd(binaryRecord), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这个方法我们可以发现stream序列化时和其他类型不一样，我们在使用json序列化一个对象时都是直接进行的，而这里分了两步并且序列化器是用于第二部转换，那么<code>ObjectRecord</code>是怎么转换成<code>MapRecord</code>的呢？点进<code>StreamObjectMapper.toMapRecord</code>方法可以看到其实是通过<code>ObjectRecord#toMapRecord</code>方法完成的，这个方法需要一个<code>HashMapper</code>用于将对象的属性/属性值映射构造成Map类型，你会发现<code>opsForStream</code>方法重载了一个默认无参的方法，而这个方法默认使用的是<code>ObjectHashMapper</code>，在我们构造<code>StreamMessageListenerContainerOptionsBuilder</code>时调用<code>targetType</code>时默认使用的也是<code>ObjectHashMapper</code>。而这个<code>ObjectHashMapper</code>会将对象中的属性和属性值转换成<code>byte[]</code>形式，所以在第一步之后这个<code>MapRecord</code>中的值的类型已经是<code>byte[]</code>了，那么也就导致第二步在使用json序列化器转换为<code>ByteRecord</code>时出现这种情况：<code>objectMapper.writeValueAsBytes(byte[])</code>，这是一个测试实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="keyword">byte</span>[] value = <span class="string">"534619360@qq.com"</span>.getBytes();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = mapper.writeValueAsBytes(value);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">    <span class="comment">//输出"NTM0NjE5MzYwQHFxLmNvbQ=="</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反应到stream中值就变成了\“NTM0NjE5MzYwQHFxLmNvbQ==\“（引号需要转义）。为了便于理解，我们可以使用设置使用json序列化器的<code>RedisTemplate</code>进行<code>add</code>断点debug测试看一下转换后的两个<code>Record</code>中的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringRedisTemplate.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line">    MailInfo mailInfo = <span class="keyword">new</span> MailInfo(<span class="string">"534619360@qq.com"</span>, <span class="string">"send mail"</span>);</span><br><span class="line">    stringRedisTemplate.opsForStream().add(Record.of(mailInfo).withStreamKey(channel));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试并断点查看<code>MapRecord</code>和<code>ByteRecord</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200628204658.png" alt=""></div><div class="image-caption"></div></figure><p>使用Redis Desktop Manager查看值：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200628204930.png" alt=""></div><div class="image-caption"></div></figure><p>测试结束终端抛出上面提到的异常。这个问题解决办法就是使用<code>String</code>序列化器也就是使用<code>StringRedisTemplate</code>，因为这个序列化器不能序列化<code>byte[]</code>类型的对象，使用这个序列化器在序列化时如果已经是<code>byte[]</code>，那么就会直接返回原<code>byte[]</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200628210421.png" alt=""></div><div class="image-caption"></div></figure><p>更具体的细节可以跟着<code>add</code>方法debug一遍。</p><h3 id="ReadOffset使用错误导致group中消费者消费失败"><a href="#ReadOffset使用错误导致group中消费者消费失败" class="headerlink" title="ReadOffset使用错误导致group中消费者消费失败"></a>ReadOffset使用错误导致group中消费者消费失败</h3><p>异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RedisCommandExecutionException: ERR The $ ID is meaningless in the context of XREADGROUP: you want to read the history of this consumer by specifying a proper ID, or use the &gt; ID to get new messages. The $ ID would just return an empty result set.</span><br></pre></td></tr></table></figure><p>上面<code>StreamOffset</code>中也提到了，这涉及到<code>0</code>、<code>&gt;</code>、<code>$</code>的使用场景和范围，如果出现这个异常，很有可能你在消费者组模式下设置消费者读取的offset时使用了<code>ReadOffset.latest()</code>，而这个对应着<code>$</code>，也就是最新一条记录。如果不明白那么你可能对这三个标识符的使用还不是很理解，最好的解决办法就是使用redis命令先完整的操作一遍。</p><h3 id="stream或者group不存在导致启动抛出异常"><a href="#stream或者group不存在导致启动抛出异常" class="headerlink" title="stream或者group不存在导致启动抛出异常"></a>stream或者group不存在导致启动抛出异常</h3><p>同样在上面提到了，在构造<code>StreamMessageListenerContainer</code>时需要stream和group存在才可以。解决方法就是提前检查并初始化，上面已给出代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实在实践之初，我在网上也搜了很多相关的资料，但是发现这些资料基本都是使用redis-cli进行命令上的操作，并没有<code>SpringBoot</code>中实现。这次实践可谓是艰辛，由于目前该支持的迭代次数比较少，不乏一些bug或者小问题（2.3已经比较稳定），并且只有<code>lettuce</code>提供了stream类型的操作实现，而<code>lettuce</code>本身又有些小毛病，这些因素结合在一起也就导致这个过程花费了我整整两天时间，而这篇博客又花了整整一下午的时间才算完成，其中可能有些内容因为涉及东西比较多只能粗略提一下，并且语言组织上不太好可能不好去理解。话说回来，这篇文章也算是我自己实践后的一个个人总结吧，这个过程其实学到的东西还是很多的，也不枉费花了这么多时间。如果你发现文章有什么地方有问题或者有什么地方不理解，也欢迎在评论区留言一起交流~</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://lolico.me/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://lolico.me/tags/SpringBoot/"/>
    
      <category term="Redis" scheme="https://lolico.me/tags/Redis/"/>
    
      <category term="MQ" scheme="https://lolico.me/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>WPF单文件发布${basedir}无效导致日志无法写入的问题</title>
    <link href="https://lolico.me/2020/06/20/WPF%E5%8D%95%E6%96%87%E4%BB%B6%E5%8F%91%E5%B8%83basedir%E6%97%A0%E6%95%88%E5%AF%BC%E8%87%B4%E6%97%A5%E5%BF%97%E6%97%A0%E6%B3%95%E5%86%99%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://lolico.me/2020/06/20/WPF%E5%8D%95%E6%96%87%E4%BB%B6%E5%8F%91%E5%B8%83basedir%E6%97%A0%E6%95%88%E5%AF%BC%E8%87%B4%E6%97%A5%E5%BF%97%E6%97%A0%E6%B3%95%E5%86%99%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-20T04:51:36.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>还是<code>NLog</code>问题，虽然<code>NLog</code>上手简单，配置容易，但是在<code>NetCore3</code>下还是有一些坑的，虽然这不是<code>NLog</code>的问题。因为这个问题百度一圈都无果，所以在这里记录一下，希望可以帮助到百度的同学（虽然这个站点没有提交到百度收录？逃~</p><h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>好，那么现在回到主题。前一阵子在用<code>WPF</code>来做一个<code>First</code>、<code>Follow</code>集算法模拟的工具，项目中使用<code>NLog</code>记录日志，在<code>NetCore 3.1</code>下作为单文件发布。发布后<code>File</code>类型的日志<code>target</code>没有将日志如期写入到文件中。并且仅在单文件发布并且<code>fileName</code>使用相对路径或者<code>${basedir}</code>指定基础目录时，才会出现这个问题，其实这个问题的解决方法很简单，只需稍微改一下就可以解决。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用<code>${basedir:fixtempdir=true}</code>指定基础目录。</p><p>这个问题主要原因其实是<code>NetCore3</code>单文件发布时<code>AppDomain.BaseDirectory</code>无法正确引用基础路径的问题，并且微软并没有打算在<code>NetCore3</code>修复这个问题，或许<code>NetCore5</code>会修复这个问题吧，文末会放几个链接，感兴趣可以去看看。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>又水了一篇文章，最近文章质量有点差，上个月还鸽掉了一篇Aop详解的文章（其实一直都在<code>draft</code>中），感觉有点罪恶感 :D</p><hr><p><em>参考：</em></p><ul><li><a href="https://github.com/dotnet/aspnetcore/issues/12621" target="_blank" rel="noopener">PublishSingleFile excluding appsettings not working as expected</a></li><li><a href="https://github.com/dotnet/runtime/issues/3704" target="_blank" rel="noopener">Single file publish: AppContext.BaseDirectory doesn’t point to apphost directory</a></li><li><a href="https://github.com/NLog/NLog/issues/3808" target="_blank" rel="noopener">When .net core app published as single file - ${basedir} is wrong</a></li><li><a href="https://stackoverflow.com/questions/62445319/why-cannot-write-log-to-files-when-wpf-application-publishing-as-a-single-file/62456300#62456300" target="_blank" rel="noopener">Why cannot write log to files when WPF application publishing as a single file</a></li><li><a href="https://github.com/nlog/nlog/wiki/Basedir-Layout-Renderer" target="_blank" rel="noopener">Basedir layout renderer</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Asp.Net Core" scheme="https://lolico.me/tags/Asp-Net-Core/"/>
    
      <category term="NLog" scheme="https://lolico.me/tags/NLog/"/>
    
      <category term="WPF" scheme="https://lolico.me/tags/WPF/"/>
    
  </entry>
  
  <entry>
    <title>Asp.Net Core中使用NLog路由不生效问题</title>
    <link href="https://lolico.me/2020/06/16/ASP-NET-CORE%E4%B8%AD%E4%BD%BF%E7%94%A8NLog%E8%B7%AF%E7%94%B1%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>https://lolico.me/2020/06/16/ASP-NET-CORE%E4%B8%AD%E4%BD%BF%E7%94%A8NLog%E8%B7%AF%E7%94%B1%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-16T13:44:44.000Z</published>
    <updated>2022-04-09T14:18:50.400Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>在一次将<code>Asp.net Core</code>默认日志换成<code>NLog</code>时，发现<code>NLog</code>配置文件中的设置不生效？具体的来说就是在<code>NLog</code>文件中设置的路由以及对应的日志级别只有在<code>Info</code>或者以上时才生效，而<code>Debug</code>、<code>Trace</code>级别则不会有日志输出。比如我的<code>NLog</code>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nlog</span> <span class="attr">xmlns</span>=<span class="string">"http://www.nlog-project.org/schemas/NLog.xsd"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.nlog-project.org/schemas/NLog.xsd NLog.xsd"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">autoReload</span>=<span class="string">"true"</span> <span class="attr">throwExceptions</span>=<span class="string">"false"</span> <span class="attr">throwConfigExceptions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">internalLogLevel</span>=<span class="string">"Warn"</span> <span class="attr">internalLogFile</span>=<span class="string">"$&#123;basedir&#125;/logs/internal.log"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"logDirectory"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/logs"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">assembly</span>=<span class="string">"NLog.Web.AspNetCore"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">targets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-wrapper</span> <span class="attr">xsi:type</span>=<span class="string">"BufferingWrapper"</span> <span class="attr">bufferSize</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">xsi:type</span>=<span class="string">"File"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;logDirectory&#125;/$&#123;shortdate&#125;-$&#123;level&#125;.log"</span> <span class="attr">encoding</span>=<span class="string">"utf-8"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">layout</span>=<span class="string">"$&#123;longdate&#125;|$&#123;uppercase:$&#123;level&#125;&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">targets</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">targets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-wrapper</span> <span class="attr">xsi:type</span>=<span class="string">"AsyncWrapper"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">wrapper-target</span> <span class="attr">xsi:type</span>=<span class="string">"RetryingWrapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-wrapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">xsi:type</span>=<span class="string">"ColoredConsole"</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">detectConsoleAvailable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">layout</span>=<span class="string">"$&#123;longdate&#125;|$&#123;uppercase:$&#123;level&#125;&#125;|$&#123;logger&#125;|$&#123;message&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">targets</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"Microsoft.*"</span> <span class="attr">minlevel</span>=<span class="string">"Debug"</span> <span class="attr">writeTo</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"WebApplication.*"</span> <span class="attr">minlevel</span>=<span class="string">"Trace"</span> <span class="attr">writeTo</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">minlevel</span>=<span class="string">"Info"</span> <span class="attr">writeTo</span>=<span class="string">"file"</span> <span class="attr">final</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">nlog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照<code>rules</code>中的设置，<code>Microsoft</code>命名空间下<code>Debug</code>级别的日志应该都可以输出在控制台中的，但是启动后控制台的输出只有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-06-16 20:41:34.9142|INFO|Microsoft.Hosting.Lifetime|Now listening on: https:&#x2F;&#x2F;localhost:5001</span><br><span class="line">2020-06-16 20:41:34.9353|INFO|Microsoft.Hosting.Lifetime|Now listening on: http:&#x2F;&#x2F;localhost:5000</span><br><span class="line">2020-06-16 20:41:34.9353|INFO|Microsoft.Hosting.Lifetime|Application started. Press Ctrl+C to shut down.</span><br><span class="line">2020-06-16 20:41:34.9353|INFO|Microsoft.Hosting.Lifetime|Hosting environment: Development</span><br><span class="line">2020-06-16 20:41:34.9353|INFO|Microsoft.Hosting.Lifetime|Content root path: D:\workspace\csharp\WebApplication\WebApplication</span><br></pre></td></tr></table></figure><p>注意这里的格式已经应用了<code>NLog</code>中设置的布局，这说明配置文件被加载了并没有问题，但为什么日志级别的设置不生效呢？</p><h2 id="原因所在"><a href="#原因所在" class="headerlink" title="原因所在"></a>原因所在</h2><p>其实是因为<code>appsettings.{env}.json</code>中日志级别的设置覆盖了<code>Nlog</code>中的设置。在我们创建一个<code>Asp.Net Core</code>项目时，一般会帮我们创建好两个<code>appsettings.json</code>文件：</p><figure class="highlight json"><figcaption><span>appsettings.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">      <span class="attr">"Default"</span>: <span class="string">"Information"</span>,</span><br><span class="line">      <span class="attr">"Microsoft"</span>: <span class="string">"Warning"</span>,</span><br><span class="line">      <span class="attr">"Microsoft.Hosting.Lifetime"</span>: <span class="string">"Information"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"AllowedHosts"</span>: <span class="string">"*"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><figcaption><span>appsettings.Development.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">      <span class="attr">"Default"</span>: <span class="string">"Information"</span>,</span><br><span class="line">      <span class="attr">"Microsoft"</span>: <span class="string">"Warning"</span>,</span><br><span class="line">      <span class="attr">"Microsoft.Hosting.Lifetime"</span>: <span class="string">"Information"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意这里使用.net core3.1创建的模板，2.1创建的项目命名空间以及对应日志级别会有所不同。</p></blockquote><p>从这两个文件很容易发现默认的日志级别为<code>Information</code>并且<code>Microsoft</code>命名空间下的日志级别被设置成了<code>Warning</code>，当然也就覆盖了<code>NLog</code>中的设置，为什么会覆盖呢？可以思考一下。并且这里的设置能够影响到<code>NLog</code>中的设置还有一个前提：将<code>NLog</code>添加到容器，并且是以<code>DI</code>的方式来获取<code>ILogger</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Host.CreateDefaultBuilder(args)</span><br><span class="line">        .ConfigureLogging(logBuilder =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            logBuilder.ClearProviders()</span><br><span class="line">            .AddNLog(<span class="string">"NLog.config"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .ConfigureWebHostDefaults(webBuilder =&gt; webBuilder.UseStartup&lt;Startup&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你是这样添加<code>NLog</code>，然后使用<code>DI</code>在需要记录日志的类中注入<code>ILogger</code>的话，那很可能就中招了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> NLog.Logger _logger = NLog.LogManager.GetCurrentClassLogger();</span><br></pre></td></tr></table></figure><p>如果你不使用<code>DI</code>来注入而是使用上面这个方式来获取<code>logger</code>，那么就不存在这个问题。但是我们使用容器主要的目的不就是容器可以更方便的管理对象之间的依赖吗？更具体地说那就是<code>DI</code>。那这个问题该怎样解决呢？</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决的方法其实很简单：</p><p>首先删除<code>appsettings.{env}.json</code>中日志相关的设置，然后在注册<code>NLog</code>时设置最低日志级别为你所用到的最低级别（因为就算去掉了这些设置，默认的日志级别也是<code>Information</code>），这样一来，就相当于把日志级别控制和输出都交给<code>NLog</code>来管理。比如我上面的文件中给自己项目的命名空间设置了<code>Trace</code>并且已是最低级别，那么在删除<code>appsettings.{env}.json</code>中日志相关的设置后可以这样来添加<code>NLog</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Host.CreateDefaultBuilder(args)</span><br><span class="line">        .ConfigureLogging(logBuilder =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            logBuilder.ClearProviders()</span><br><span class="line">            .SetMinimumLevel(LogLevel.Trace) <span class="comment">// 最低为Trace</span></span><br><span class="line">            .AddNLog(_configFileRelativePath);</span><br><span class="line">        &#125;)</span><br><span class="line">        .ConfigureWebHostDefaults(webBuilder =&gt; webBuilder.UseStartup&lt;Startup&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者你也可以使用<code>AddFilter</code>来细分使得日志输出可以“交到”<code>NLog</code>手中。当然，如果你不想删除原有的设置并且不想通过<code>SetMinimumLevel(LogLevel)</code>方法来设置最低级别，你也可以在<code>appsettings.{env}.json</code>文件中设置命名空间和相应的日志级别来保证<code>NLog</code>中的设置不会被覆盖（因为这个文件在启动时会自动被加载）。总之，只需要保证<code>NLog</code>中日志级别的设置不会因为该文件或者默认的<code>Information</code>级别所覆盖即可。如果不使用<code>DI</code>来获取的话那就当我没说。（逃</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class=&quot;headerlink&quot; title=&quot;问题
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Asp.Net Core" scheme="https://lolico.me/tags/Asp-Net-Core/"/>
    
      <category term="NLog" scheme="https://lolico.me/tags/NLog/"/>
    
  </entry>
  
  <entry>
    <title>部署Asp.Net Core应用时遇到的两个问题</title>
    <link href="https://lolico.me/2020/06/12/%E9%83%A8%E7%BD%B2ASP-NET-CORE%E5%BA%94%E7%94%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>https://lolico.me/2020/06/12/%E9%83%A8%E7%BD%B2ASP-NET-CORE%E5%BA%94%E7%94%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-12T12:08:19.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --><p>在一次部署Asp.Net Core应用时遇到了这么几个问题：</p><ol><li>启动应用后，从<code>IConfiguration</code>中获取不到连接字符串。</li><li>使用nginx反代后，<code>Identity</code>框架页面跳转后域名被改写成了<code>localhost</code>或者<code>主机名</code>。</li></ol><p><strong>问题一：</strong></p><p>应用使用sqlite数据库，在程序启动后创建并初始化数据库，本地开发启动并没有报错，但是部署到服务器却获取不到连接字符串，报错：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200612191218.png" alt=""></div><div class="image-caption"></div></figure><p>百度和谷歌都无果，最初我还以为是程序中某个地方可能出错了，但是在WSL上经过多次测试，发现如果没有在执行文件的目录下启动了项目才会报这样的错误，这个问题很奇怪，猜测是<code>Directory.GetCurrentDirectory()</code>获取路径导致，并未求证。知道了问题所在那么解决的办法就很简单了，<code>cd</code>到执行文件目录启动即可。</p><p><strong>问题二：</strong></p><p>这个问题是宝塔面板导致的，在设置反代的发送域名后，并没有反应到配置文件中，也就是说在面板上设置<code>proxy_set_header Host $host;</code>后文件中并没有改过来，依旧是<code>localhost</code>或者<code>$hostname</code>，也就导致了页面跳转时域名变成了<code>localhost</code>或者<code>主机名</code>。解决的办法很简单，只需要手动修改nginx配置文件中的反代发送域名即可。</p><p>在这之前，其实还遇到了一个和nginx反代相关的问题：如果使用nginx来代理目录，从而实现一个域名下部署多个项目，这样做之后就导致Asp.net Core应用全部404，网上搜索一番，有些类似的问题解答提到使用<code>Microsoft.AspNetCore.HttpOverrides</code>包，但是我照着操作一番后依旧没用，目前比较笨的解决办法就是mvc的路由前手动加前缀，更好的办法目前没有找到，如果你知道，还请评论告知~</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;在一次部署Asp.Net Core应用时遇到了这么几个问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;启动应用后，从&lt;code&gt;
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Asp.Net Core" scheme="https://lolico.me/tags/Asp-Net-Core/"/>
    
      <category term="Nginx" scheme="https://lolico.me/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>在JetBrains系产品中使用非商店发行版WSL</title>
    <link href="https://lolico.me/2020/05/19/%E5%9C%A8JetBrains%E7%B3%BB%E4%BA%A7%E5%93%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%95%86%E5%BA%97%E5%8F%91%E8%A1%8C%E7%89%88WSL/"/>
    <id>https://lolico.me/2020/05/19/%E5%9C%A8JetBrains%E7%B3%BB%E4%BA%A7%E5%93%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%95%86%E5%BA%97%E5%8F%91%E8%A1%8C%E7%89%88WSL/</id>
    <published>2020-05-19T09:48:45.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --><p>JetBrains产品对于WSL提供了一定的支持，但是其只支持Microsoft Store中发行的WSL，对于类似<a href="https://github.com/yuk7/ArchWSL" target="_blank" rel="noopener">ArchWSL</a>这种非商店发行版，在配置工具链时却不能够被发现。下面给出两个方法来解决这个问题。</p><blockquote><p>由于我目前只使用过<a href="https://github.com/yuk7/ArchWSL" target="_blank" rel="noopener">ArchWSL</a>这个非商店发行版的WSL，所以下面以ArchWSL为例，对于其他版本的WSL，理论上也行得通。</p></blockquote><ol><li><p>第一种方法很简单，只需要复制执行文件到指定目录</p><p>只需将<code>Arch.exe</code>文件拷贝一份到<code>C:\Users\lolico\AppData\Local\Microsoft\WindowsApps</code>目录下即可。</p><p><em>注意，如果你安装了多个Arch，在拷贝时需要将每个版本对应的执行文件都拷贝到<code>WindowsApps</code>目录下。</em></p></li><li><p>第二种方法是网上搜索到的一个方法，并且在<a href="https://www.jetbrains.com/help/ruby/configuring-remote-interpreters-using-wsl.html#custom_wsl" target="_blank" rel="noopener">RubyMine官方文档</a>中提到了这个方法</p><p>以RubyMine为例，修改<code>wsl.distributions.xml</code>文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">descriptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>Arch<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">microsoft-id</span>&gt;</span>Arch<span class="tag">&lt;/<span class="name">microsoft-id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executable-path</span>&gt;</span>Arch.exe<span class="tag">&lt;/<span class="name">executable-path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">presentable-name</span>&gt;</span>Arch Linux<span class="tag">&lt;/<span class="name">presentable-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>executable-path</code>使用执行文件的绝对路径。</li><li><code>wsl.distributions.xml</code>文件位于产品对应的配置文件夹下，对于不同版本，配置文件夹位置可能不一样。</li></ul><blockquote><p>旧版本软件的配置文件夹在<code>%HOMEPATH%</code>下，此时该文件位于配置文件夹下的<code>config\options</code>目录中。在2020.1版本，配置文件夹迁移到了<code>%HOMEPATH%\AppData\Roaming\JetBrains</code>下，此时该文件位于配置文件夹下的<code>options</code>目录中。由于我一直使用ToolBox来安装并管理这些软件，所以说如果你并不是从ToolBox中安装的软件，新版本的配置文件夹可能仍然在<code>%HOMEPATH%</code>下。</p></blockquote></li></ol><p>最后，还想说一句，在使用商店发行版时我们可以用类似<code>\\wsl$\Ubuntu</code>这种路径来访问WSL的根目录，在使用非商店发行版时却不行，解决的办法还是上面提到第一个方法，拷贝文件到<code>WindowsApps</code>之后即可使用<code>\\wsl$\Arch</code>来访问Arch的根目录。</p><hr><p><em>参考：</em></p><p>^ <a href="https://www.jetbrains.com/help/ruby/configuring-remote-interpreters-using-wsl.html#custom_wsl" target="_blank" rel="noopener"><em>Custom WSL distributions</em></a><br>^ <a href="https://youtrack.jetbrains.com/issue/Py-32424#focus=streamItem-27-3332472.0-0" target="_blank" rel="noopener"><em>Support custom WSL distributive (not from Microsoft Store)</em></a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;JetBrains产品对于WSL提供了一定的支持，但是其只支持Microsoft Store中发行的WSL，对
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="WSL" scheme="https://lolico.me/tags/WSL/"/>
    
      <category term="IDEA" scheme="https://lolico.me/tags/IDEA/"/>
    
      <category term="WebStorm" scheme="https://lolico.me/tags/WebStorm/"/>
    
      <category term="PyCharm" scheme="https://lolico.me/tags/PyCharm/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2中AOP默认使用CGLIB代理</title>
    <link href="https://lolico.me/2020/05/03/SpringBoot2%E4%B8%ADAOP%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8CGLIB%E4%BB%A3%E7%90%86/"/>
    <id>https://lolico.me/2020/05/03/SpringBoot2%E4%B8%ADAOP%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8CGLIB%E4%BB%A3%E7%90%86/</id>
    <published>2020-05-03T11:18:32.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><p>在一次偶然情况下发现SpringBoot开发的应用在没有使用<code>@EnableAspectJAutoProxy</code>注解的情况下，AOP还是可以正常工作。不经引起了我的注意，随后便猜测SpringBoot中是否存在一个自动配置类在不使用注解的情况下完成自动配置并开启了AOP。</p><a id="more"></a><p>在Idea中尝试搜索<code>AopAutoConfiguration</code>，果然不出所料，有这么一个自动配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"auto"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Advice<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line">        <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>,</span><br><span class="line">                matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">jdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line">        <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">                matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>@ConditionalOnProperty</code>注解中<code>matchIfMissing</code>属性的设置，也正是这个属性的设置使得我们在不使用<code>@EnableAspectJAutoProxy</code>注解开启AOP的情况下，AOP也可以正常工作。</p><p>从这个自动配置类中还能够看出AOP默认使用Cglib代理。那么如果我们使用<code>@EnableAspectJAutoProxy</code>注解去指定默认不使用Cglib代理，有没有用呢？</p><p>经过测试发现，使用<code>@EnableAspectJAutoProxy</code>注解显示指定是没有用的。那么该如何设置默认使用jdk动态代理呢？根据自动配置类能知道，我们只需要在<code>application.properties</code>中指定<code>spring.aop.proxy-target-class=false</code>或者设置<code>spring.aop.auto=false</code>关闭aop自动配置后自行使用<code>@EnableAspectJAutoProxy</code>注解进行设置。</p><p>并且如果查看SpringBoot1.5.x中的这个自动配置类会发现默认是使用jdk动态代理，那么为什么在SpringBoot2.x中改为默认使用Cglib了呢？</p><blockquote><p>使用jdk动态代理会存在一个代理问题：目标对象一定要实现接口。因为jdk动态代理是基于接口的，并且意味着当使用<code>@Autowired</code>注入一个使用jdk代理生成的对象时必须使用接口。</p></blockquote><p>就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure><p>一旦使用实现类的方式进行注入就会失败：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserServiceImpl userService;</span><br></pre></td></tr></table></figure><p>使用Cglib代理就不存在这个问题，原因就在于Cglib是使用子类的方式进行代理。</p><p>当查看类似<code>@EnableCaching</code>、<code>@EnableAsync</code>、<code>@EnableTransactionManagement</code>注解中<code>proxyTargetClass</code>属性的注释，我们还会发现注释中说到，这个属性设置为true后会影响Spring管理的所有Bean使用的代理方式。但是我经过测试发现其他注解的这个属性设置为true时并不会影响<code>@EnableAsync</code>的代理方式。但是<code>@EnableAsync</code>的这个属性设置为true后会影响其他注解下对象的代理方式。(SpringBoot2.2.2下测试)</p><p>注意：<code>proxyTargetClass</code>属性默认为false时并不意味着如果目标对象没有实现接口，生成代理类就会失败，这种情况下Spring会使用Cglib代理。</p><hr><p><em>参考：</em></p><p>^ <a href="https://github.com/spring-projects/spring-boot/issues/5423" target="_blank" rel="noopener"><em>Use @EnableTransactionManagement(proxyTargetClass = true)</em></a><br>^ <a href="https://github.com/spring-projects/spring-boot/issues/8434" target="_blank" rel="noopener"><em>@EnableTransactionManagement proxyTargetClass not control by spring.aop.proxyTargetClass</em></a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;在一次偶然情况下发现SpringBoot开发的应用在没有使用&lt;code&gt;@EnableAspectJAutoProxy&lt;/code&gt;注解的情况下，AOP还是可以正常工作。不经引起了我的注意，随后便猜测SpringBoot中是否存在一个自动配置类在不使用注解的情况下完成自动配置并开启了AOP。&lt;/p&gt;
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://lolico.me/tags/Spring/"/>
    
      <category term="AOP" scheme="https://lolico.me/tags/AOP/"/>
    
      <category term="SpringBoot" scheme="https://lolico.me/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity跨域</title>
    <link href="https://lolico.me/2020/04/26/SpringSecurity%E8%B7%A8%E5%9F%9F/"/>
    <id>https://lolico.me/2020/04/26/SpringSecurity%E8%B7%A8%E5%9F%9F/</id>
    <published>2020-04-26T16:01:12.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在SpringSecurity中配置跨域，我相信所有用过SpringSecurity的人应该都知道，因为实在是太简单了。那我为什么还要写这篇文章呢？写这篇文章的目的当然不是去解释如何配置跨域，而是通过分析Spring对跨域支持的源码来感受设计中的优雅。</p><p>先声明一下开发环境：<code>SpringBoot：2.2.2</code></p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>既然说到SpringSecurity配置跨域，那么我们就先简单复习一下如何配置跨域。</p><h3 id="配置跨域"><a href="#配置跨域" class="headerlink" title="配置跨域"></a>配置跨域</h3><p>我们都知道集成SpringSecurity后配置跨域我们只需要在继承<code>WebSecurityConfigurerAdapter</code>类，重写<code>configure(HttpSecurity http)</code>方法，开启<code>cors</code>并提供一个跨域配置源即可。下面是一个例子：</p><figure class="highlight java"><figcaption><span>开启跨域</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.sessionManagement()</span><br><span class="line">            .sessionCreationPolicy(SessionCreationPolicy.STATELESS) <span class="comment">// 前后端分离</span></span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable() <span class="comment">// 禁用csrf</span></span><br><span class="line">            .cors(); <span class="comment">// 跨域</span></span><br><span class="line">    <span class="comment">// ... 省略其他配置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提供一个CorsConfigurationSource</span></span><br><span class="line"><span class="comment">// 这里直接注册成Bean即可，注意方法名必须是corsConfigurationSource，后面会解释</span></span><br><span class="line"><span class="comment">// 也可以cors().configurationSource(corsConfigurationSource())指定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CorsConfigurationSource <span class="title">corsConfigurationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CorsConfiguration configuration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">    configuration.addAllowedOrigin(<span class="string">"*"</span>); <span class="comment">// 根据实际的需要去设置</span></span><br><span class="line">    configuration.addAllowedMethod(<span class="string">"*"</span>); <span class="comment">// 同上</span></span><br><span class="line">    configuration.addAllowedHeader(<span class="string">"*"</span>); </span><br><span class="line">    configuration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line">    configuration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">"/**"</span>, configuration);</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就如前面所说，只需要开启<code>cors</code>再提供一个跨域配置源即可。方法很简单，但这里有个坑需要注意一下。</p><h4 id="暴露公共接口时跨域的一个坑"><a href="#暴露公共接口时跨域的一个坑" class="headerlink" title="暴露公共接口时跨域的一个坑"></a>暴露公共接口时跨域的一个坑</h4><blockquote><p>如果我们还重写了<code>configure(WebSecurity web)</code>方法，使用<code>web.ignoring().antMatchers(ignorePaths)</code>去暴露一个公共接口’/pub’那么上面的跨域配置对这个接口来说就没用，也就是说这个接口会出现跨域问题。然而我们原本就是为了提供公共接口’/pub’，但现在却有跨域问题，那怎么能行！！！（一般来说这个方法是对静态资源设置直接放行，而不是公共接口！）</p></blockquote><p><em>那这到底是为什么呢？</em></p><p><strong>因为SpringSecurity配置跨域支持，是通过<code>CorsFilter</code>过滤器来实现的</strong>，我们<code>web.ignoring()</code>中设置后对应的接口请求就不会经过<code>CorsFilter</code>来处理，这个接口当然就存在跨域问题了！之所以说<em>这个方法是对静态资源设置直接放行，而不是公共接口</em>也是这个原因，那正确的方法是什么呢？还是<code>configure(HttpSecurity http)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.sessionManagement()</span><br><span class="line">            .sessionCreationPolicy(SessionCreationPolicy.STATELESS) <span class="comment">// 前后端分离</span></span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable() <span class="comment">// 禁用csrf</span></span><br><span class="line">            .cors() <span class="comment">// 跨域</span></span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">"/pub/**"</span>).permitAll() <span class="comment">// 匿名通过认证</span></span><br><span class="line">            .anyRequest().authenticated() <span class="comment">//剩下的任何请求都需要认证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cors方法"><a href="#cors方法" class="headerlink" title="cors方法"></a>cors方法</h3><p>现在我们来看一下<code>cors()</code>方法，点进这个方法看看，其实很简单，就是应用了一个<code>CorsConfigurer</code>配置类。如果看过<code>SpringSecurity</code>自动配置，对形如<code>xxxConfigurer</code>的类名应该不陌生。<br>这个<code>Configurer</code>其实就是在”FilterChain”上添加了一个过滤器，即<code>CorsFilter</code></p><p>我们都知道<code>CorsFilter</code>的构造方法需要一个<code>CorsConfigurationSource</code>，在请求到来时，使用<code>CorsProcessor</code>根据提供的<code>CorsConfiguration</code>去对请求进行处理（在<code>CorsFilter</code>中默认是<code>DefaultCorsProcessor</code>）而<code>CorsConfiguration</code>是通过<code>CorsConfigurationSource#getCorsConfiguration</code>方法获得的，所以说怎么获得<code>CorsConfigurationSource</code>至关重要。</p><p>还记得上面在配置<code>CorsConfigurationSource</code>时，我们直接注册Bean而不是通过<code>configurationSource()</code>方法指定吗？这种方法为什么是可行的呢？来看一下<code>CorsConfigurer</code>是如何获得<code>CorsConfigurationSource</code>并构造<code>CorsFilter</code>的：</p><figure class="highlight java"><figcaption><span>CorsConfigurer#getCorsFilter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CorsFilter <span class="title">getCorsFilter</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果指定了CorsConfigurationSource，那么用指定的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.configurationSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(<span class="keyword">this</span>.configurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> containsCorsFilter = context.containsBeanDefinition(CORS_FILTER_BEAN_NAME);</span><br><span class="line">    <span class="comment">//如果容器中已经有名字是’corsFilter‘的bean，则用已经有的</span></span><br><span class="line">    <span class="keyword">if</span> (containsCorsFilter) &#123; </span><br><span class="line">        <span class="keyword">return</span> context.getBean(CORS_FILTER_BEAN_NAME, CorsFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> containsCorsSource = context.containsBean(CORS_CONFIGURATION_SOURCE_BEAN_NAME);</span><br><span class="line">    <span class="comment">//如果既没有指定，容器中也不存在名字是’corsFilter‘的CorsFilter</span></span><br><span class="line">    <span class="comment">//那么看一下容器中有没有名字是’corsConfigurationSource‘的CorsConfigurationSource</span></span><br><span class="line">    <span class="comment">//如果有，取出来作为CorsConfigurationSource</span></span><br><span class="line">    <span class="keyword">if</span> (containsCorsSource) &#123;</span><br><span class="line">        CorsConfigurationSource configurationSource = context.getBean(CORS_CONFIGURATION_SOURCE_BEAN_NAME, CorsConfigurationSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(configurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果也没有corsConfigurationSource，看看类路径下存不存在HandlerMappingIntrospector这个类</span></span><br><span class="line">    <span class="keyword">boolean</span> mvcPresent = ClassUtils.isPresent(HANDLER_MAPPING_INTROSPECTOR,context.getClassLoader());</span><br><span class="line">    <span class="keyword">if</span> (mvcPresent) &#123; <span class="comment">//如果存在</span></span><br><span class="line">        <span class="keyword">return</span> MvcCorsFilter.getMvcCorsFilter(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcCorsFilter</span> </span>&#123; <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME = <span class="string">"mvcHandlerMappingIntrospector"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> CorsFilter <span class="title">getMvcCorsFilter</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!context.containsBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME, <span class="string">"A Bean named "</span> + </span><br><span class="line">            HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME +<span class="string">" of type "</span> + HandlerMappingIntrospector<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span></span><br><span class="line">            + " is required to use MvcRequestMatcher. Please ensure Spring Security &amp; Spring MVC are configured in a shared ApplicationContext.");</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从容器中取出HandlerMappingIntrospector作为CorsConfigurationSource</span></span><br><span class="line">        HandlerMappingIntrospector mappingIntrospector = context.getBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME, HandlerMappingIntrospector<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(mappingIntrospector);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取<code>CorsConfigurationSource</code>并构造<code>CorsFilter</code>的步骤注释里写的很清楚了，正常来说我们配置跨域配置源不管是直接指定也好，还是注册成Bean也好（注意Bean名字的要求），都是可以被获取到的。一般情况下，我们也的确是这样做的（直接提供一个<code>CorsConfigurationSource</code>）。但为什么最后有<code>MvcCorsFilter.getMvcCorsFilter(context)</code>这样一个调用？通过这个方法里抛出的异常信息不难猜测到是SpringSecurity为了兼容SpringMVC中配置跨域的方式。</p><p>还记得不使用SpringSecurity时如何在SpringMVC中配置支持跨域吗？</p><p><strong>两种方式：</strong></p><ul><li>将<code>@CrossOrigin</code>注解标注在支持跨域的接口上</li><li>重写<code>WebMvcConfigurer#addCorsMappings</code>方法进行全局配置</li></ul><p>看到这里你可能会猜测：是不是<code>HandlerMappingIntrospector</code>实现了<code>CorsConfigurationSource</code>，并且是根据上面两种方式的配置来返回跨域配置的呢？</p><p>事实上，的确是这样的。为了便于理解后面给出的代码，先来看看<code>CorsFilter</code>类和<code>CorsConfigurationSource</code>接口：</p><h4 id="CorsConfigurationSource"><a href="#CorsConfigurationSource" class="headerlink" title="CorsConfigurationSource"></a>CorsConfigurationSource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CorsConfigurationSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">CorsConfiguration <span class="title">getCorsConfiguration</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跨域配置源，实现类要实现<code>getCorsConfiguration</code>方法返回一个<code>CorsConfiguration</code>跨域配置，其中包含允许那些域、请求方法、请求头，是否允许携带凭证，缓存时间是多久，允许携带的头属性等信息。</p><p><code>CorsConfigurationSource</code>有五个实现类：</p><ul><li>CorsInterceptor</li><li>HandlerMappingIntrospector</li><li>PreFlightHandler</li><li>ResourceHttpRequestHandler</li><li>UrlBasedCorsConfigurationSource</li></ul><h4 id="CorsFilter"><a href="#CorsFilter" class="headerlink" title="CorsFilter"></a>CorsFilter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CorsConfigurationSource configSource;</span><br><span class="line">    <span class="keyword">private</span> CorsProcessor processor = <span class="keyword">new</span> DefaultCorsProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CorsFilter</span><span class="params">(CorsConfigurationSource configSource)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(configSource, <span class="string">"CorsConfigurationSource must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.configSource = configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorsProcessor</span><span class="params">(CorsProcessor processor)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(processor, <span class="string">"CorsProcessor must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.processor = processor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取CorsConfiguration</span></span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">this</span>.configSource.getCorsConfiguration(request);</span><br><span class="line">        <span class="comment">// 根据CorsConfiguration处理请求</span></span><br><span class="line">        <span class="keyword">boolean</span> isValid = <span class="keyword">this</span>.processor.processRequest(corsConfiguration, request, response);</span><br><span class="line">        <span class="keyword">if</span> (!isValid || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultCorsProcessor#processRequest</code>中根据请求是否跨域，是否是预检请求以及<code>CorsConfiguration</code>等信息来对请求进行处理和在响应头中写入一些信息。具体的源码就不分析了，还是比较好理解的。前提是需要对CORS有一定的了解，可以看下<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS）</a>这篇文章。</p><h3 id="HandlerMappingIntrospector"><a href="#HandlerMappingIntrospector" class="headerlink" title="HandlerMappingIntrospector"></a>HandlerMappingIntrospector</h3><p><code>HandlerMappingIntrospector</code>比较特别，不要认为这是个拦截器，”Introspector”翻译成中文是<em>内省者</em>的意思。</p><p>这个类在初始化后会调用<code>afterPropertiesSet</code>方法，将容器中所有的<code>HandlerMapping</code>添加到该类的<code>handlerMappings</code>这个<code>List</code>中。</p><p>来看一下官方对于这个类的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Helper class to get information from the HandlerMapping that would serve a specific request.</span><br><span class="line">Provides the following methods:</span><br><span class="line">    - getMatchableHandlerMapping(javax.servlet.http.HttpServletRequest) — obtain a HandlerMapping to check request-matching criteria against.</span><br><span class="line">    - getCorsConfiguration(javax.servlet.http.HttpServletRequest) — obtain the CORS configuration for the request.</span><br></pre></td></tr></table></figure><blockquote><p>这个类是一个帮助类，用于从<code>HandlerMapping</code>中获取请求的特定信息，提供了两个方法。第一个方法用于获取一个<code>MatchableHandlerMapping</code>来检查请求匹配条件，第二个方法用于获取适用于这个请求的<code>CorsConfiguration</code>跨域配置。</p></blockquote><p>我们重点关注第二个方法：</p><figure class="highlight java"><figcaption><span>HandlerMappingIntrospector#getCorsConfiguration</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CorsConfiguration <span class="title">getCorsConfiguration</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(<span class="keyword">this</span>.handlerMappings, <span class="string">"Handler mappings not initialized"</span>);</span><br><span class="line">    HttpServletRequest wrapper = <span class="keyword">new</span> RequestAttributeChangeIgnoringWrapper(request);</span><br><span class="line">    <span class="keyword">for</span> (HandlerMapping handlerMapping : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">        HandlerExecutionChain handler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler = handlerMapping.getHandler(wrapper); <span class="comment">// 获取处理执行链</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler.getInterceptors() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历拦截器，如果拦截器同时实现了CorsConfigurationSource则用这个拦截器作为跨域配置源</span></span><br><span class="line">            <span class="keyword">for</span> (HandlerInterceptor interceptor : handler.getInterceptors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> CorsConfigurationSource) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ((CorsConfigurationSource) interceptor).getCorsConfiguration(wrapper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从执行链获取处理器，如果处理器本身也实现了CorsConfigurationSource，则用处理器作为跨域配置源</span></span><br><span class="line">        <span class="keyword">if</span> (handler.getHandler() <span class="keyword">instanceof</span> CorsConfigurationSource) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((CorsConfigurationSource) handler.getHandler()).getCorsConfiguration(wrapper);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>CorsConfigurationSource</code>实现类根据请求从<code>HandlerMapping</code>中获取获取<code>HandlerExecutionChain</code>执行链，再依次从执行链的拦截器和处理器中获取<code>CorsConfigurationSource</code>，如果获取到了再调用其<code>HandlerMappingIntrospector#getCorsConfiguration</code>方法返回跨域配置。具体来说就是那两个if判断。</p><p>所以这么说来的话，<code>HandlerMappingIntrospector</code>虽然实现了<code>CorsConfigurationSource</code>但其本质有点像一个委托类？它检查请求对应的执行链上的拦截器和处理器有没有实现<code>CorsConfigurationSource</code>，如果有，再委托给这个<code>CorsConfigurationSource</code>来获取<code>CorsConfiguration</code>。所以说如果我们在一个<code>Controller</code>的接口上标注了<code>@CrossOrigin</code>注解，那么对应的，在拦截器中获取不到<code>CorsConfiguration</code>，就会从这个Handler上获取到<code>CorsConfiguration</code>，也就是将<code>@CrossOrigin</code>注解中提供的信息封装成了<code>CorsConfiguration</code>。那为什么还会先检查执行链中的拦截器呢？</p><p>因为SpringMVC中还有第二种方法配置跨域支持，也就是上面提到的重写<code>WebMvcConfigurer#addCorsMappings</code>方法进行全局配置。那为什么重写这个方法添加跨域配置最后会注册成拦截器呢？（一个实现了<code>CorsConfigurationSource</code>的拦截器）</p><p>这就要说到SpringBoot在WebMvc的自动配置、<code>WebMvcConfigurer</code>和<code>HandlerMapping</code>了。</p><p>如果你有仔细看过SpringBoot在SpringMVC的自动配置方面的源码，你一定知道<code>WebMvcConfigurationSupport</code>这个最主要的配置类在注册<code>HandlerMapping</code>的时候会从一个<code>CorsRegisty</code>中获取跨域配置：（这里以<code>RequestMappingHandlerMapping</code>为例）</p><figure class="highlight java"><figcaption><span>WebMvcConfigurationSupport.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">requestMappingHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Qualifier(<span class="string">"mvcContentNegotiationManager"</span>)</span> ContentNegotiationManager contentNegotiationManager,</span></span><br><span class="line"><span class="function">        @<span class="title">Qualifier</span><span class="params">(<span class="string">"mvcConversionService"</span>)</span> FormattingConversionService conversionService,</span></span><br><span class="line"><span class="function">        @<span class="title">Qualifier</span><span class="params">(<span class="string">"mvcResourceUrlProvider"</span>)</span> ResourceUrlProvider resourceUrlProvider) </span>&#123;</span><br><span class="line">            </span><br><span class="line">    RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping();</span><br><span class="line">    mapping.setOrder(<span class="number">0</span>);</span><br><span class="line">    mapping.setInterceptors(getInterceptors(conversionService, resourceUrlProvider));</span><br><span class="line">    mapping.setContentNegotiationManager(contentNegotiationManager);</span><br><span class="line">    mapping.setCorsConfigurations(getCorsConfigurations()); <span class="comment">//设置跨域配置</span></span><br><span class="line">    <span class="comment">// ...省略一大段set</span></span><br><span class="line">    <span class="keyword">return</span> mapping;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, CorsConfiguration&gt; <span class="title">getCorsConfigurations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.corsConfigurations == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CorsRegistry registry = <span class="keyword">new</span> CorsRegistry();</span><br><span class="line">        addCorsMappings(registry);  <span class="comment">//向CorsRegistry中添加跨域映射</span></span><br><span class="line">        <span class="keyword">this</span>.corsConfigurations = registry.getCorsConfigurations(); <span class="comment">//获取跨域配置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.corsConfigurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addCorsMappings()</code>方法是个空方法，并且只有<code>DelegatingWebMvcConfiguration</code>类重写了这个方法。实际上<code>WebMvcConfigurationSupport</code>这个类中用<code>@Bean</code>这个可传递的注解标注了很多方法但该类上并没有标注<code>@Configuration</code>，那么为什么还会起到配置类的作用呢？其实真正的配置类是<code>DelegatingWebMvcConfiguration</code>。</p><h3 id="DelegatingWebMvcConfiguration"><a href="#DelegatingWebMvcConfiguration" class="headerlink" title="DelegatingWebMvcConfiguration"></a>DelegatingWebMvcConfiguration</h3><p>在<code>DelegatingWebMvcConfiguration</code>这个类上有个<code>@Configuration</code>注解，并且继承自<code>WebMvcConfigurationSupport</code>，实际上它就是个委托类。</p><p><em>可以说这个类才是真正的配置类，去看看<code>DelegatingWebMvcConfiguration</code>这个类，相信你一定会发现什么！！！</em></p><p><code>DelegatingWebMvcConfiguration</code>中有<code>WebMvcConfigurerComposite</code>这么一个对象，并且将容器中所有<code>WebMvcConfigurer</code>注入进来：</p><figure class="highlight java"><figcaption><span>DelegatingWebMvcConfiguration.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// WebMvcConfigurer复合类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebMvcConfigurerComposite configurers = <span class="keyword">new</span> WebMvcConfigurerComposite();</span><br><span class="line">    <span class="comment">// 将容器中所有WebMvcConfigurer添加到WebMvcConfigurerComposite</span></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你去看了一下这个类的源码，你就会发现<code>WebMvcConfigurer</code>中有的方法这个类都有，并且这个委托类仅仅是将请求委托给<code>configurers</code>，来看看重写的<code>addCorsMappings</code>方法：</p><figure class="highlight java"><figcaption><span>DelegatingWebMvcConfiguration#addCorsMappings</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configurers.addCorsMappings(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>WebMvcConfigurerComposite#addCorsMappings</code>，显而易见<code>WebMvcConfigurerComposite</code>是个复合的<code>WebMvcConfigurer</code>，他也实现了<code>WebMvcConfigurer</code>并且内部维护了一个<code>List&lt;WebMvcConfigurer&gt; delegates</code>列表，实现的所有方法会依次调用列表中<code>WebMvcConfigurer</code>对应的方法。（并且你还能发现<code>WebMvcConfigurer</code>中的方法都是作为回调方法并且大部分是返回void的）</p><blockquote><p>说到这里，不得不说一个题外话。如果看Spring源码比较多的话，就会发现Spring中类的命名都有规律可循并且某些后缀都是有特定意义的，比如<code>xxxComposite</code>、<code>xxxConfigurer</code>、<code>Delegatingxxx</code>、<code>xxxDelegator</code>等等，这样我们看到这个类名就立马能猜到它的作用。</p></blockquote><p>我们平时对WebMvc进行一些配置都是实现<code>WebMvcConfigurer</code>类，重写其中的方法。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"*"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到这，也就是相当于<code>WebMvcConfigurationSupport#getCorsConfigurations</code>方法会回调容器中所有<code>WebMvcConfigurer</code>实现类的<code>addCorsMappings()</code>方法，向<code>CorsRegistry</code>中添加跨域映射，然后再取出<code>CorsConfiguration</code>返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, CorsConfiguration&gt; <span class="title">getCorsConfigurations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.corsConfigurations == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CorsRegistry registry = <span class="keyword">new</span> CorsRegistry();</span><br><span class="line">        addCorsMappings(registry); <span class="comment">//向CorsRegistry中添加跨域映射</span></span><br><span class="line">        <span class="keyword">this</span>.corsConfigurations = registry.getCorsConfigurations(); <span class="comment">//获取跨域配置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.corsConfigurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后反应到<code>AbstractHandlerMapping</code>中的就是使用<code>CorsConfiguration</code>注册一个<code>CorsInterceptor</code>拦截器，这个拦截器是<code>AbstractHandlerMapping</code>中的一个内部类，继承自<code>HandlerInterceptorAdapter</code>，并且实现了<code>CorsConfigurationSource</code>。</p><blockquote><p>看到这里，如果没有了解过<code>HandlerMapping</code>，可能会一头雾水，可以看看我的这篇文章<a href="/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/" title="源码角度分析Spring容器启动阶段注册Controller处理器的流程">源码角度分析Spring容器启动阶段注册Controller处理器的流程</a>，虽然不是讲<code>HandlerMapping</code>，但是相信在看完后，会对<code>HandlerMapping</code>有一个理解。</p></blockquote><h3 id="CorsInterceptor"><a href="#CorsInterceptor" class="headerlink" title="CorsInterceptor"></a>CorsInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> <span class="keyword">implements</span> <span class="title">CorsConfigurationSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CorsConfiguration config;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CorsInterceptor</span><span class="params">(@Nullable CorsConfiguration config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> corsProcessor.processRequest(<span class="keyword">this</span>.config, request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsConfiguration <span class="title">getCorsConfiguration</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类只重写了拦截器的<code>preHandle</code>方法，其他方法都是空方法。而且你能发现这个<code>preHandle</code>方法中的内容和<code>CorsFilter#doFilterInternal</code>方法基本是一模一样的，都是根据<code>CorsConfiguration</code>使用跨域处理器处理请求。</p><p>看到这里，现在应该知道关于<code>HandlerMappingIntrospector</code>的猜测是没错的，并且知道了<code>HandlerMappingIntrospector</code>是如何与SpringMVC两种支持跨域的配置方式联系起来的，这里再次总结一下：</p><ol><li>首先获取请求对应的执行链上的拦截器，判断拦截器有没有实现<code>CorsConfigurationSource</code>（<code>CorsInterceptor</code>类），如果有则调用<code>getCorsConfiguration</code>获取<code>CorsConfiguration</code>后返回</li><li>如果拦截器上获取失败，则判断处理器有没有实现<code>CorsConfigurationSource</code>（<code>PreFlightHandler</code>类），如果有则调用<code>getCorsConfiguration</code>获取<code>CorsConfiguration</code>后返回</li></ol><p>从而实现了兼容SpringMVC中两种配置跨域的方式。</p><p>这其中最关键的几点就在于<code>CorsConfigurer</code>获取<code>CorsConfigurationSource</code>并且构造<code>CorsFilter</code>的步骤、<code>HandlerMappingIntrospector</code>获取<code>CorsConfiguration</code>的步骤，还有Spring回调<code>WebMvcConfigurer</code>对<code>HandlerMapping</code>进行设置跨域配置等信息的步骤</p><p>其中还涉及到了SpringMVC中<code>HandlerMapping</code>、<code>HandlerExecutionChain</code>、<code>Handler</code>、<code>Interceptor</code>等相关知识。</p><p><strong>根据这次的分析，能得到几个结论：</strong></p><ul><li>SpringMVC支持跨域两种方式一个是基于处理器实现，另一个是基于拦截器实现。</li><li>SpringSecurity跨域是基于过滤器，并且兼容了SpringMVC的两种配置（使用<code>HandlerMappingIntrospector</code>“桥接”）。</li><li>SpringSecurity中的<code>CorsConfigurer</code>使用<code>HandlerMappingIntrospector</code>来兼容SpringMVC跨域两种方式。</li><li><code>HandlerMappingIntrospector</code>获取<code>CorsConfiguration</code>时的优先级是先拦截器，再处理器。</li><li>SpringBoot注册<code>HandlerMapping</code>或者说通过<code>WebMvcAutoConfiguration</code>自动配置来对WebMvc必要的组件进行装配和注入。</li><li><code>WebMvcConfigurer</code>是<code>DelegatingWebMvcConfiguration</code>类驱动<code>WebMvcConfigurerComposite</code>来进行回调的。</li></ul><p>并且经过这次的源码阅读，也是足足感受到Spring设计上的优雅。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>文章写的有点乱，并且有点跳跃。仅仅是跟着文章来看可能不大能看懂，最好在电脑上根据源码来阅读。这篇文章也仅仅是作为我个人在一次踩坑后好奇心大法，阅读源码后的一段总结以及感悟吧，自己能看懂并且以后还能看懂也就满意了。如果这篇文章有幸被你刷到并且你能够看懂我想表达的那我自然是更高兴。其实这个博客存在的理由也仅仅是为了记录自己学习过程中的感悟和总结，便于自己以后回顾，<del>毕竟我比较健忘</del>。所以需要记录下有必要的，并且在个人看来，这篇文章干货还是足足的，所以说更加有必要记录。其实在写文章之初我也不想写这么一篇文章，因为实在是太难写明白了，并且由于涉及到的东西比较分散很难进行组织，<del>也可能我表达能力差的原因吧</del>，但最终还是花了一下午加一晚上，在不断修改下产出了这么一篇很长很长很长的文章，可能是写过的字数最多的文章了吧😥。文章中可能有错别字也可能有错误的内容，如果你发现文章有什么错误的地方或者没表述清楚的内容，欢迎在评论中交流。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在SpringSecurity中配置跨域，我相信所有用过SpringSecurity的人应该都知道，因为实在是太简单了。那我为什么还要写这篇文章呢？写这篇文章的目的当然不是去解释如何配置跨域，而是通过分析Spring对跨域支持的源码来感受设计中的优雅。&lt;/p&gt;&lt;p&gt;先声明一下开发环境：&lt;code&gt;SpringBoot：2.2.2&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://lolico.me/tags/Spring/"/>
    
      <category term="Web" scheme="https://lolico.me/tags/Web/"/>
    
      <category term="Security" scheme="https://lolico.me/tags/Security/"/>
    
      <category term="SpringBoot" scheme="https://lolico.me/tags/SpringBoot/"/>
    
      <category term="CORS" scheme="https://lolico.me/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>VueJS学习笔记</title>
    <link href="https://lolico.me/2020/04/24/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://lolico.me/2020/04/24/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-24T14:47:31.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>原本是打算写一个<em>VueJS学习笔记</em>专栏，用于记录vue学习过程中的一些感想，但后来想想，如此做实在是太麻烦，并且每篇文章的篇幅也会比较短，所以现在考虑直接在这一篇博文中进行总结。将学习过程中的感谢或者踩得一些坑直接记录在此一篇文章中，尽量做到每个点都短小精悍。该篇博文并非最终稿，内容会随着文章的更新不断丰富。</p><p><strong>官方中文文档</strong>：</p><ul><li>Guide：<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></li><li>API：<a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/</a></li><li>Style Guide：<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/style-guide/</a></li><li>Examples：<a href="https://cn.vuejs.org/v2/examples/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/examples/</a></li></ul><blockquote><p>下面大部分内容都可以从官方文档中找到。这篇总结，仅将我个人认为有必要记录的进行汇总，以方便后续查找和回顾。</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ol><li>在选项属性或者回调方法使用箭头函数会导致在方法内使用<code>this</code>获取不到vue实例</li></ol><figure class="highlight javascript"><figcaption><span>错误示范</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">created: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">vm.$watch(<span class="string">'a'</span>, newValue =&gt; <span class="keyword">this</span>.myMethod())</span><br></pre></td></tr></table></figure><ol start="2"><li>事件总线机制下，监听总线事件的回调方法要使用箭头函数，否则this指代总线实例。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted()&#123; <span class="comment">// 挂载后执行</span></span><br><span class="line">  EventBus.$on(<span class="string">'event-name'</span>,data =&gt; &#123; <span class="comment">// 这里要用箭头函数，否则this指代EventBus</span></span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>v-bind</code>、<code>v-on</code>、<code>v-slot</code>指令使用<a href="https://cn.vuejs.org/v2/guide/syntax.html#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">动态指令参数</a>（2.6.0+）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">attr</span>]=<span class="string">"value"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">"value"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #[<span class="attr">solt</span>]&gt;</span>...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>attr</code>、<code>event</code>和<code>solt</code>会作为一个javascript表达式进行求值</p><ol start="4"><li><p>在DOM中使用模板时，避免使用大写字符来命名键名，因为浏览器会把attribute名全部强制转换为小写。</p></li><li><p>数据一般是从父组件流向子组件的，prop的值会因父组件中数据的改变而改变。</p></li><li><p>不要修改prop的值，如果一定要这么做，请使用计算属性或者data。</p></li><li><p>计算属性默认只有getter，但是我们也可以提供一个setter。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">        <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>父组件中的data可以是一个对象也可以是一个方法，但是子组件的data属性必须是一个方法。</p></li><li><p>由于JavaScript的限制，<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">Vue不能检测数组和对象的变化</a>。也就是说对对象的属性或数组进行修改添加删除不会反应到视图中（但值的却改变了），可以使用<code>vm.$set</code><a href="https://cn.vuejs.org/v2/api/#vm-set" target="_blank" rel="noopener">实例方法</a>（全局方法的别名），或<code>Vue.set</code><a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">全局方法</a>。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    lisi:&#123;</span><br><span class="line">      age: <span class="number">16</span>    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.lisi.age = <span class="number">18</span>; <span class="comment">// 直接对对象属性进行修改是不会直接响应到视图中</span></span><br><span class="line">vm.$<span class="keyword">set</span>(this.lisi,'age',18); // 响应式</span><br></pre></td></tr></table></figure><ol start="10"><li><code>v-if</code>和<code>v-show</code>的<a href="https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show" target="_blank" rel="noopener">异同</a>：</li></ol><ul><li><code>v-if</code>指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</li><li><code>v-show</code>指令通过修改元素的display属性让其显示或者隐藏</li></ul><ol start="11"><li><p>使用<code>v-cloak</code><a href="https://cn.vuejs.org/v2/api/#v-cloak" target="_blank" rel="noopener">指令</a>解决页面加载时闪烁的问题</p></li><li><p><a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">事件修饰符</a>、<a href="https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">按键修饰符</a>以及<a href="https://cn.vuejs.org/v2/guide/events.html#%E7%B3%BB%E7%BB%9F%E4%BF%AE%E9%A5%B0%E9%94%AE" target="_blank" rel="noopener">系统修饰键</a></p></li><li><p>使用<code>ref</code><a href="https://cn.vuejs.org/v2/api/#ref" target="_blank" rel="noopener">属性</a>在父组件中<a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">调用子组件的方法</a>。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span> Click this button &#123;&#123;count&#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">children</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span> Click this button &#123;&#123;count&#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> btn = &#123;</span></span><br><span class="line"><span class="actionscript">        template: <span class="string">'#btn'</span>,</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                count: 0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            add() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.count++;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            add() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.count++;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.$refs.child.add(); <span class="comment">// 调用子组件方法</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line"><span class="actionscript">            <span class="string">'children'</span>: btn</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Vue.js" scheme="https://lolico.me/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>修改评论插件为gitalk</title>
    <link href="https://lolico.me/2020/04/24/%E4%BF%AE%E6%94%B9%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%E4%B8%BAgitalk/"/>
    <id>https://lolico.me/2020/04/24/%E4%BF%AE%E6%94%B9%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%E4%B8%BAgitalk/</id>
    <published>2020-04-24T08:45:20.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><p>正式将评论插件由<a href="https://valine.js.org" target="_blank" rel="noopener">valine</a>更改为<a href="//github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a>，提高了评论的门槛，但考虑到文章受众以及博客类型，还是可以接受的。之前的评论丢失，<del>后续也可能会考虑回到<a href="https://valine.js.org" target="_blank" rel="noopener">valine</a></del>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;正式将评论插件由&lt;a href=&quot;https://valine.js.org&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="不正常的文章" scheme="https://lolico.me/categories/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次无法获取Vue实例的坑</title>
    <link href="https://lolico.me/2020/04/22/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%9D%91/"/>
    <id>https://lolico.me/2020/04/22/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%9D%91/</id>
    <published>2020-04-22T14:16:44.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --><blockquote><p>不要在选项属性或回调上使用箭头函数，比如<code>created: () =&gt; console.log(this.a)</code>或<code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。因为箭头函数并没有<code>this</code>，<code>this</code>会作为变量一直向上级词法作用域查找，直至找到为止，经常导致<code>Uncaught TypeError: Cannot read property of undefined</code>或<code>Uncaught TypeError: this.myMethod is not a function</code>之类的错误。</p></blockquote><a id="more"></a><p>错误示范：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primay"</span> <span class="attr">icon</span>=<span class="string">"el-icon-plus"</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// ...</span></span></span><br><span class="line">        data: &#123;</span><br><span class="line">            count: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            add: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.count++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确示范：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        methods: &#123;</span><br><span class="line">            add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.count++</span><br><span class="line">            &#125;,</span><br><span class="line">            minus() &#123;</span><br><span class="line">                <span class="keyword">this</span>.count--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --&gt;&lt;blockquote&gt;&lt;p&gt;不要在选项属性或回调上使用箭头函数，比如&lt;code&gt;created: () =&amp;gt; console.log(this.a)&lt;/code&gt;或&lt;code&gt;vm.$watch(&amp;#39;a&amp;#39;, newValue =&amp;gt; this.myMethod())&lt;/code&gt;。因为箭头函数并没有&lt;code&gt;this&lt;/code&gt;，&lt;code&gt;this&lt;/code&gt;会作为变量一直向上级词法作用域查找，直至找到为止，经常导致&lt;code&gt;Uncaught TypeError: Cannot read property of undefined&lt;/code&gt;或&lt;code&gt;Uncaught TypeError: this.myMethod is not a function&lt;/code&gt;之类的错误。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Vue.js" scheme="https://lolico.me/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Git连接多个GitHub账号</title>
    <link href="https://lolico.me/2020/04/15/Git%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AAGitHub%E8%B4%A6%E5%8F%B7/"/>
    <id>https://lolico.me/2020/04/15/Git%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AAGitHub%E8%B4%A6%E5%8F%B7/</id>
    <published>2020-04-15T11:11:50.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用ssh连接GitHub，需要在GitHub账号上传唯一的公钥。当我们需要连接两个或多个GitHub账号，上传同一个公钥是不允许的，那么该如何设置才能在一台电脑上连接多个GitHub账号呢？</p><a id="more"></a><h2 id="创建密钥并上传到GitHub"><a href="#创建密钥并上传到GitHub" class="headerlink" title="创建密钥并上传到GitHub"></a>创建密钥并上传到GitHub</h2><p>假设我们已经有一对默认的密钥<code>id_rsa</code>、<code>id_rsa.pub</code>关联了a账号，现在我们来为b账号创建一个密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_b -C <span class="string">"youmail@example.com"</span></span><br></pre></td></tr></table></figure><p>注意文件名不要与其他的密钥重复，否则会覆盖之前的密钥。<br>windows下使用绝对路径：<code>C:\Users\xxx\.ssh\id_rsa_b</code></p><p>接下来我们就可以在用户目录下的<code>.ssh</code>文件夹中找到<code>id_rsa_b</code>和<code>id_rsa_b.pub</code>两个文件，将<code>id_rsa_b.pub</code>文件中的内容保存到b账号的ssh keys中。</p><h2 id="配置身份验证使用的密钥"><a href="#配置身份验证使用的密钥" class="headerlink" title="配置身份验证使用的密钥"></a>配置身份验证使用的密钥</h2><p>接下来我们要做的就是对不同账号配置使用不同的密钥去连接github。在<code>.ssh</code>文件夹中创建一个<code>config</code>文件（无扩展名），填入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># default</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line"></span><br><span class="line"># b</span><br><span class="line">Host b.github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_b</span><br></pre></td></tr></table></figure><p>在这部分配置中我们使用不同的主机标识去映射同一个<code>HostName</code>即github.com，但是我们使用不同的密钥文件去进行身份验证。</p><p>配置中的<code>Host</code>在不和其他<code>Host</code>重复的情况下可以随意填写，但是建议使用一眼就能看懂的标识（并且这个标识在后面是需要用到的）</p><p>到这里，其实所有的工作都已经完成。在进行下一步操作前我们先测试ssh是否能连接到github：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@b.github.com</span><br></pre></td></tr></table></figure><p>不出意外，我们将看到验证成功的提示。如果提示 CreateProcessW failed error:2，先将config文件中的代理设置注释便可，实际上并不影响后续对仓库的推送。</p><h2 id="对b账号的仓库单独设置用户名和邮箱"><a href="#对b账号的仓库单独设置用户名和邮箱" class="headerlink" title="对b账号的仓库单独设置用户名和邮箱"></a>对b账号的仓库单独设置用户名和邮箱</h2><p>现在我们要做的就是对b账号下的仓库进行设置，因为在原本只有一个账号时，我们应该都用过下面这个命令来对git设置一个全局的用户名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"a"</span></span><br><span class="line">git config --global user.email <span class="string">"a@example.com"</span></span><br></pre></td></tr></table></figure><p>现在我们当然不能对b账号下的仓库也使用全局的用户名和邮箱。如果使用全局的邮箱将b的仓库push到github，那么在github提交记录中看到的提交者将会是a，所以说我们需要对b账号下的仓库单独配置用户名和邮箱，进入项目文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">"b"</span></span><br><span class="line">git config user.email <span class="string">"b@example.com"</span></span><br></pre></td></tr></table></figure><p>邮箱要使用b账号注册github时使用的邮箱，因为github提交记录中的提交者是根据这个邮箱来查找的，这也是不能使用全局邮箱后提交者是a的原因。</p><h2 id="修改远程仓库的地址"><a href="#修改远程仓库的地址" class="headerlink" title="修改远程仓库的地址"></a>修改远程仓库的地址</h2><p>接下来我们还要重新设置远程仓库的地址，因为克隆仓库或者创建github仓库添加远程仓库地址时使用的主机标识默认是<code>github.com</code>，然而在config文件中对这个<code>Host</code>是使用<code>~/.ssh/id_rsa</code>密钥去验证，所以当我们本地已有b账号下的仓库或者未来克隆b账号下的仓库时要修改默认的远程仓库地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@b.github.com:b/repo.git</span><br></pre></td></tr></table></figure><p>注意不要照抄，根据config文件中配置的<code>Host</code>，github账号以及仓库名去设置‘@’符号后面的东西。</p><p>所有的工作都已经完成，push测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>如果我们单纯的使用<code>git push</code>可能会报错，因为虽然添加了远程仓库，但是并没有设置本地分支具体跟踪哪个上游分支。使用<code>-u</code>或<code>--set-upstream-to</code>选项运行<code>git branch</code>来显式地设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/master master</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，我们就是使用了不同的主机标识去映射github.com，并且对不同的标识在连接github时使用相应的密钥去验证身份。我们设置多个标识，相应的，我们也要修改远程仓库使用的Host标识（因为克隆下来的仓库的远程地址Host标识默认使用github.com）。虽然上面我们是拿两个账号来举例子，但是对于多个账号，设置的方法还是一模一样的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;用ssh连接GitHub，需要在GitHub账号上传唯一的公钥。当我们需要连接两个或多个GitHub账号，上传同一个公钥是不允许的，那么该如何设置才能在一台电脑上连接多个GitHub账号呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="git" scheme="https://lolico.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>python3安装dlib库</title>
    <link href="https://lolico.me/2020/04/12/python3%E5%AE%89%E8%A3%85dlib%E5%BA%93/"/>
    <id>https://lolico.me/2020/04/12/python3%E5%AE%89%E8%A3%85dlib%E5%BA%93/</id>
    <published>2020-04-12T06:44:09.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><p>python3编译安装dlib库十分麻烦，这里提供已经编译好的whl文件，使用pip直接安装即可。</p><a id="more"></a><ul><li><p>python3.6<br>下载：<a href="https://lolico.griouges.cn/download/dlib/dlib-19.8.1-cp36-cp36m-win_amd64.whl" target="_blank" rel="noopener">dlib-19.8.1-cp36-cp36m-win_amd64.whl</a><br>md5：9a704406fbb4036f70b5f174fec9db1f<br>sha1：e2e49b82b8dee6a9483362713239558c42c38fea</p></li><li><p>python3.7<br>下载：<a href="https://lolico.griouges.cn/download/dlib/dlib-19.17.99-cp37-cp37m-win_amd64.whl" target="_blank" rel="noopener">dlib-19.17.99-cp37-cp37m-win_amd64.whl</a><br>md5：b8c35e6e0098a7ece3e1a6935bbf1ae8<br>sha1：886f510821c3033649edcf86ea80ec1157f0b1a7</p></li><li><p>python3.8<br>下载：<a href="https://lolico.griouges.cn/download/dlib/dlib-19.19.0-cp38-cp38-win_amd64.whl" target="_blank" rel="noopener">dlib-19.19.0-cp38-cp38-win_amd64.whl</a><br>md5：7e00b04c3cf468e102b338d6837f4d5d<br>sha1：129d0142f1232d60c6571dc07eacdcd392b92f7b</p></li></ul><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install dlib-xx.xx.xx-cpxx-cpxx-win_amd64.whl  <span class="comment">#安装相应的文件</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;python3编译安装dlib库十分麻烦，这里提供已经编译好的whl文件，使用pip直接安装即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Python" scheme="https://lolico.me/tags/Python/"/>
    
      <category term="pip" scheme="https://lolico.me/tags/pip/"/>
    
      <category term="dlib" scheme="https://lolico.me/tags/dlib/"/>
    
  </entry>
  
  <entry>
    <title>解锁网易云音乐</title>
    <link href="https://lolico.me/2020/03/23/%E8%A7%A3%E9%94%81%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    <id>https://lolico.me/2020/03/23/%E8%A7%A3%E9%94%81%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/</id>
    <published>2020-03-23T10:26:55.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过配置下文中的代理，实现解锁网易云无版权音乐以及试听音乐，文中使用到的项目：<a href="https://github.com/nondanee/UnblockNeteaseMusic" target="_blank" rel="noopener">UnblockNeteaseMusic</a>。</p><blockquote><p>注意：互联网并非法外之地，此代理完全免费并仅用作学习与交流，使用过程中出现任何问题本人概不负责。如发现任何收费倒卖等行为请及时举报并反馈。</p></blockquote><h2 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h2><p>使用前你需要知道：</p><p>服务端已做限制：<em>仅允许代理网易云相关域名和ip的请求，其他请求一律拒绝。</em>由于服务器带宽只有5Mbps，所以理论速度不会超过640kb/s。如果使用的人比较多，可能出现加载比较慢的现象。建议网易云音乐内<strong>开启边听边存</strong>，常听的歌<strong>下载到本地</strong>。最后，你也可以通过文末的打赏按钮对我进行打赏鼓励~（大雾</p><p>现提供两种方法，不想折腾的使用<code>方法一</code>（局限性较大），否则请选择<code>方法二</code>（推荐）。</p><h3 id="方法一：系统代理PAC"><a href="#方法一：系统代理PAC" class="headerlink" title="方法一：系统代理PAC"></a>方法一：系统代理PAC</h3><p>使用系统代理PAC解锁是最简单的方法，缺点是 Android 和 iOS 只能在连接WiFi的环境下使用。下面介绍不同平台系统代理PAC的设置方法，对号入座。</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>以 Windows 10 为例，进入「Windows 设置」&gt;「网络和 Internet」&gt;「代理」&gt;「自动设置代理」&gt;「使用设置脚本」，填写以下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.lolico.me:39000&#x2F;proxy.pac</span><br></pre></td></tr></table></figure><p>进入网易云音乐「设置」&gt;「工具」&gt;「Http代理」，选择「使用 IE 代理设置」。</p><h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><p>进入「系统偏好设置」&gt;「网络」&gt;「高级」&gt;「代理」，填写以下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.lolico.me:39000&#x2F;proxy.pac</span><br></pre></td></tr></table></figure><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>进入「设置」&gt;「WLAN」&gt;「修改网络」&gt;「高级选项」&gt;「代理」&gt;「代理自动配置」（不同机型设置的地方不一样，也可能在wifi右边的感叹号中），填写以下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.lolico.me:39000&#x2F;proxy.pac</span><br></pre></td></tr></table></figure><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><p>首先下载<a href="https://raw.githubusercontent.com/nondanee/UnblockNeteaseMusic/master/ca.crt" target="_blank" rel="noopener">CA证书</a>（打不开的请挂代理），前往“设置-通用-描述文件”，安装「UnblockNeteaseMusic Root CA」，然后在“设置-通用-关于本机-证书信任设置”处开启对「UnblockNeteaseMusic Root CA」的信任，最后给当前连接的wifi配置http代理，选择自动并填入以下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.lolico.me:39000&#x2F;proxy.pac</span><br></pre></td></tr></table></figure><h3 id="方法二：代理软件"><a href="#方法二：代理软件" class="headerlink" title="方法二：代理软件"></a>方法二：代理软件</h3><p>使用代理软件，任何网络环境都可用，下面放上不同平台主流代理软件的使用步骤，至于文中没有提到的客户端，能力者自行根据提供的现有配置修改。</p><h4 id="Clash-for-Windows"><a href="#Clash-for-Windows" class="headerlink" title="Clash for Windows"></a>Clash for Windows</h4><ol><li>👉<a href="https://lolico.griouges.cn/download/clash/Clash.for.Windows.Setup.exe" target="_blank" rel="noopener">安装软件</a></li><li>👉<a href="clash://install-config?url=https%3a%2f%2flolico.me%2fsubscribe%2fClash%2fconfig.yaml">导入配置文件</a></li><li>👉进入「General」，开启「System Proxy」</li><li>👉进入网易云音乐「设置」&gt;「工具」&gt;「Http代理」，选择「使用 IE 代理设置」。</li></ol><h4 id="Clash-for-MacOS"><a href="#Clash-for-MacOS" class="headerlink" title="Clash for MacOS"></a>Clash for MacOS</h4><ol><li>👉<a href="https://lolico.griouges.cn/download/clash/ClashX.dmg" target="_blank" rel="noopener">安装软件</a></li><li>👉<a href="clash://install-config?url=https%3a%2f%2flolico.me%2fsubscribe%2fClash%2fconfig.yaml">导入配置文件</a></li></ol><h4 id="Clash-for-Android"><a href="#Clash-for-Android" class="headerlink" title="Clash for Android"></a>Clash for Android</h4><ol><li>👉<a href="https://lolico.griouges.cn/download/clash/app-armeabi-v7a-release.apk" target="_blank" rel="noopener">安装软件</a></li><li>👉<a href="clash://install-config?url=https%3a%2f%2flolico.me%2fsubscribe%2fClash%2fconfig.yaml">导入配置文件</a></li><li>👉保存后应用此配置</li><li>👉回到主界面启动代理</li></ol><p><strong>注意：</strong></p><p><del>鉴于安卓端<code>导入配置文件</code>无法调起Clash进行自动导入，请手动导入配置：</del>（最新版已支持，上方直接下载）</p><ol><li>👉进入Clash应用，依次点击「配置」&gt;「新配置」&gt;「从URL导入」</li><li>👉填写名称：lolico.me，URL地址：<a href="https://lolico.me/subscribe/Clash/config.yaml">https://lolico.me/subscribe/Clash/config.yaml</a> ，自动更新：1440</li><li>👉保存后选中此配置</li><li>👉回到主界面启动代理</li></ol><blockquote><p>Clash配置中有多个节点，当节点不可用时，请切换至其他节点或尝试更新配置文件。</p></blockquote><h4 id="iOS-1"><a href="#iOS-1" class="headerlink" title="iOS"></a>iOS</h4><p>首先下载<a href="https://raw.githubusercontent.com/nondanee/UnblockNeteaseMusic/master/ca.crt" target="_blank" rel="noopener">CA证书</a>（打不开的请挂代理），前往“设置-通用-描述文件”，安装「UnblockNeteaseMusic Root CA」，然后在“设置-通用-关于本机-证书信任设置”处开启对「UnblockNeteaseMusic Root CA」的信任。</p><h5 id="Shadowrocket"><a href="#Shadowrocket" class="headerlink" title="Shadowrocket"></a>Shadowrocket</h5><ol><li>👉<a href="https://apps.apple.com/us/app/shadowrocket/id932747118" target="_blank" rel="noopener">安装软件</a></li><li>👉<a href="shadowrocket://add/sub://aHR0cHM6Ly9sb2xpY28ubWUvc3Vic2NyaWJlL1NoYWRvd3JvY2tldC9zZXJ2ZXIudHh0#%F0%9F%8E%B8%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90">导入节点</a></li><li>👉<a href="shadowrocket://config/add/https://lolico.me/subscribe/Shadowrocket/rules.conf">导入配置</a></li></ol><h5 id="QuantumultX"><a href="#QuantumultX" class="headerlink" title="QuantumultX"></a>QuantumultX</h5><ol><li>👉<a href="https://apps.apple.com/us/app-bundle/quantumult-x-upgrade/id1482985563" target="_blank" rel="noopener">安装软件</a></li><li>👉<a href="quantumult-x:///update-configuration?remote-resource=%7B%0A%20%20%20%20%22server_remote%22%3A%20%5B%0A%20%20%20%20%20%20%20%20%22https%3A%2F%2Flolico.me%2Fsubscribe%2FQuantumultX%2FNeteaseMusicServer.txt%2C%20tag%3DNetease%20Music%2C%20img-url%3Dhttps%3A%2F%2Fraw.githubusercontent.com%2FKoolson%2FQure%2Fmaster%2FIconSet%2FNetease_Music_Unlock.png%22%0A%20%20%20%20%5D%2C%0A%20%20%20%20%22filter_remote%22%3A%20%5B%0A%20%20%20%20%20%20%20%20%22https%3A%2F%2Flolico.me%2Fsubscribe%2FQuantumultX%2FNeteaseMusicFilter.txt%2C%20tag%3D%F0%9F%8E%B8%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2C%20force-policy%3D%F0%9F%8E%B8%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2C%20enabled%3Dtrue%22%0A%20%20%20%20%5D%0A%7D">导入配置</a></li><li>👉进入应用，长按<code>🎸网易云音乐</code>策略组并添加解锁节点</li></ol><p>这里另外再提供一个包含：策略组、常用分流、脚本订阅的精简全局配置文件（适用于QuantumultX v1.0.10及以上版本）：<a href="https://lolico.me/subscribe/QuantumultX/simple.conf">https://lolico.me/subscribe/QuantumultX/simple.conf</a></p><blockquote><p>注意：如果测试节点连接延迟显示<code>timeout/超时</code>是正常的，服务端开启严格模式后仅能通过网易云相关域名或ip的请求。</p></blockquote><blockquote><p>部分解锁节点来自telegram频道，如有侵权，请联系删除，谢谢！</p></blockquote><hr><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li><p>为什么开启代理后，听数字专辑中的音乐会提示购买？</p><p>直接搜数字专辑中的音乐在播放时可能出现这种现象，尝试从专辑中进入并播放。</p></li><li><p>为什么开启代理后，登录网易云音乐提示网络异常？</p><p>先关闭代理再进行登录，进入后再开启代理。</p></li><li><p>为什么播放音乐提示网络不给力或者歌曲不存在？</p><p>iOS端出现网络不给力时，请确保CA证书已信任；歌曲不存在，请尝试使用其他节点解锁，不同节点在搜索音源时使用的平台不同，部分歌曲找不到是正常的现象。</p></li><li><p>为什么播放的音乐是live版或者完全不同的一首音乐？</p><p>由于解锁服务是从其他平台搜索音源，并且选择策略不可能做到十全十美，在音乐重名并且火热程度不同的情况下，可能会出现这种现象，目前没有较好的解决方法。</p></li><li><p>为什么开启代理后某些网站或应用加载资源很慢甚至失败？</p><p>由于使用代理并且根据请求分流，所以说相比不开代理理论上的确会有延迟（基本忽略不计）。如果感觉有明显的网络延迟并且确定不是由于自己网络环境较差所致，请在<em>必要时</em>再开启代理，日常上网关闭即可。</p></li><li><p>这写的都是些啥玩意？</p><p>……</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --&gt;
    
    </summary>
    
    
      <category term="不正常的文章" scheme="https://lolico.me/categories/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌套列表推导式</title>
    <link href="https://lolico.me/2020/03/15/%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/"/>
    <id>https://lolico.me/2020/03/15/%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/</id>
    <published>2020-03-15T06:36:20.000Z</published>
    <updated>2022-04-09T14:18:50.404Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --><p>列表解析中的第一个表达式可以是任何表达式，包括列表解析。</p><p>考虑下面由三个长度为 4 的列表组成的 3x4 矩阵：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [</span><br><span class="line"><span class="meta">... </span>    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"><span class="meta">... </span>]</span><br></pre></td></tr></table></figure><p>现在，如果你想交换行和列，可以用嵌套的列表推导式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>像前面看到的，嵌套的列表推导式是对 for 后面的内容进行求值，所以上例就等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>反过来说，如下也是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># the following 3 lines implement the nested listcomp</span></span><br><span class="line"><span class="meta">... </span>    transposed_row = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line"><span class="meta">... </span>        transposed_row.append(row[i])</span><br><span class="line"><span class="meta">... </span>    transposed.append(transposed_row)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>在实际中，使用内置函数组成复杂流程语句。对此种情况<code>zip()</code>函数将会做的更好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 09 2022 14:19:08 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;列表解析中的第一个表达式可以是任何表达式，包括列表解析。&lt;/p&gt;&lt;p&gt;考虑下面由三个长度为 4 的列表组成的 
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Python" scheme="https://lolico.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2020年JetBrains Quest第三弹</title>
    <link href="https://lolico.me/2020/03/14/2020%E5%B9%B4JetBrains-Quest%E7%AC%AC%E4%B8%89%E5%BC%B9/"/>
    <id>https://lolico.me/2020/03/14/2020%E5%B9%B4JetBrains-Quest%E7%AC%AC%E4%B8%89%E5%BC%B9/</id>
    <published>2020-03-14T08:52:33.000Z</published>
    <updated>2022-04-09T14:18:50.400Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --><p>2020年3月13，JetBrains Quest第三弹到来：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314165330.png" alt=""></div><div class="image-caption"></div></figure><a id="more"></a><p>给个提示，上面的那一串是经过了<em>Base64编码</em></p><p>解谜后这次的奖励是一张8折优惠券？？？</p><br><br><br><br><br><br><br><br><br><br><p>算了算了，告辞</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Apr 09 2022 14:19:07 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;2020年3月13，JetBrains Quest第三弹到来：&lt;/p&gt;&lt;figure class=&quot;image-bubble&quot;&gt;&lt;div class=&quot;img-lightbox&quot;&gt;&lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;&lt;img src=&quot;https://lolico.griouges.cn/images/20200314165330.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="不正常的文章" scheme="https://lolico.me/categories/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="JetBrains Quest" scheme="https://lolico.me/tags/JetBrains-Quest/"/>
    
  </entry>
  
</feed>
