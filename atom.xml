<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lolico.me/"/>
  <updated>2022-02-17T12:19:03.229Z</updated>
  <id>https://lolico.me/</id>
  
  <author>
    <name>mmmmx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Stream消息队列在SpringBoot中的实践与踩坑</title>
    <link href="https://lolico.me/2020/06/28/Using-stream-to-implement-message-queue-in-springboot/"/>
    <id>https://lolico.me/2020/06/28/Using-stream-to-implement-message-queue-in-springboot/</id>
    <published>2020-06-28T13:54:57.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Redis5</code>新增了一个<code>Stream</code>的数据类型，这个类型作为消息队列来使用时弥补了<code>List</code>和<code>Pub/Sub</code>的不足并且提供了更强大的功能，比如<code>ack</code>机制以及消费者组等概念，在有轻量消息队列使用需求时，使用这个新类型那是再好不过了。对于这个类型，在这里就不赘述了，想了解的话可以看一下这篇<a href="http://www.hellokang.net/redis/stream.html#_1-%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">文章</a>，在这里，我们就具体来讲一下在<code>SpringBoot</code>中的实践与踩坑。</p><p>注意，<code>SpringBoot</code>版本需要大于2.2（即<code>spring-data-redis</code>需要大于2.2）。</p><h2 id="新API和类"><a href="#新API和类" class="headerlink" title="新API和类"></a>新API和类</h2><p>在开始正文之前，我们先简单了解一下在2.2引入的和Stream操作相关的方法和类。</p><h3 id="消息和消息ID的对象"><a href="#消息和消息ID的对象" class="headerlink" title="消息和消息ID的对象"></a>消息和消息ID的对象</h3><p>消息（或者称为记录）和消息ID在Spring-Data-Redis中使用<code>Record</code>和<code>RecordId</code>来表示。</p><p>一个<code>Record</code>包含三部分内容：</p><ul><li><code>stream</code>表示这个消息要发往那个Stream，也就是Stream的key</li><li><code>recordId</code>表示这个消息的ID，一般Redis服务器自动生成，也可以指定</li><li><code>value</code>表示消息内容</li></ul><p>SpringBoot为我们提供了五种消息类型的抽象：<code>MapRecord</code>、<code>ObjectRecord</code>、<code>ByteRecord</code>、<code>ByteBufferRecord</code>、<code>StringRecord</code>，以及一个消息ID类型：<code>RecordId</code>。</p><blockquote><p>这里另外说一下：其实除开<code>ObjectRecord</code>，其他几个<code>Record</code>都是通过继承<code>MapRecord</code>扩展而来的。<code>StringRecord</code>中的消息内容也并非仅仅是一个字符串，而是一个键值都为字符串类型的<code>Map</code>（<code>ByteRecord</code>、<code>ByteBufferRecord</code>同理）。而<code>ObjectRecord</code>最后也会使用<code>HashMapper</code>转换成<code>MapRecord</code>。为什么最后都是操作<code>Map</code>类型？这是因为Stream中的内容是以多个<code>key-value</code>这种键值对的形式存储的。</p></blockquote><p>那么我们怎样去创建一个消息对象呢？</p><p>一般来说我们使用前两个消息类型比较多，所以Spring-Data-Redis很贴心的在<code>Record</code>这个顶级接口中提供了两个静态方法用于直接构造<code>MapRecord</code>和<code>ObjectRecord</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;S, K, V&gt; <span class="function">MapRecord&lt;S, K, V&gt; <span class="title">of</span><span class="params">(Map&lt;K, V&gt; map)</span></span></span><br><span class="line"><span class="function">    Assert.<span class="title">notNull</span><span class="params">(map, <span class="string">"Map must not be null!"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> StreamRecords.mapBacked(map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;S, V&gt; <span class="function">ObjectRecord&lt;S, V&gt; <span class="title">of</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(value, <span class="string">"Value must not be null!"</span>);</span><br><span class="line">    <span class="keyword">return</span> StreamRecords.objectBacked(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这两个方法实际上是调用了<code>StreamRecords</code>中提供的静态方法来创建，<code>StreamRecords</code>这个类提供了下面这些方法用于创建五种<code>Record</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ByteRecord <span class="title">rawBytes</span><span class="params">(Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; raw)</span> </span></span><br><span class="line"><span class="function">ByteBufferRecord <span class="title">rawBuffer</span><span class="params">(Map&lt;ByteBuffer, ByteBuffer&gt; raw)</span> </span></span><br><span class="line"><span class="function">StringRecord <span class="title">string</span><span class="params">(Map&lt;String, String&gt; raw)</span></span></span><br><span class="line"><span class="function">&lt;S, K, V&gt; MapRecord&lt;S, K, V&gt; <span class="title">mapBacked</span><span class="params">(Map&lt;K, V&gt; map)</span></span></span><br><span class="line"><span class="function">&lt;S, V&gt; ObjectRecord&lt;S, V&gt; <span class="title">objectBacked</span><span class="params">(V value)</span></span></span><br><span class="line"><span class="function">RecordBuilder&lt;?&gt; <span class="title">newRecord</span><span class="params">()</span>  <span class="comment">// 通过builder方式创建</span></span></span><br></pre></td></tr></table></figure><p>当然，我们还可以通过使用某个具体的<code>Record</code>类型的<code>create</code>静态方法来创建，下面是几个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String streamKey = <span class="string">"channel:stream:key1"</span>;<span class="comment">//stream key</span></span><br><span class="line">MailInfo mailInfo = <span class="keyword">new</span> MailInfo(<span class="string">"554205726@qq.com"</span>, <span class="string">"sendmail"</span>);<span class="comment">//定义一个Object类型的消息内容</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">    put(<span class="string">"receiver"</span>, <span class="string">"534619360@qq.com"</span>);</span><br><span class="line">&#125;&#125;; <span class="comment">//定义一个Map类型的消息内容</span></span><br><span class="line">Record.of(mailInfo).withStreamKey(streamKey);</span><br><span class="line">Record.of(map).withStreamKey(streamKey).withId(RecordId.of(<span class="string">"123"</span>));<span class="comment">//指定id</span></span><br><span class="line">StreamRecords.objectBacked(mailInfo).withStreamKey(streamKey);</span><br><span class="line">StreamRecords.mapBacked(map).withStreamKey(streamKey).withId(RecordId.autoGenerate());<span class="comment">//指定id</span></span><br><span class="line">ObjectRecord.create(streamKey, mailInfo); <span class="comment">//使用ObjectRecord的create静态方法创建</span></span><br></pre></td></tr></table></figure><p>如果我们不通过<code>withId</code>方法显示调用去指定<code>id</code>，那么默认的情况下就是使用<code>RecordId.autoGenerate()</code>自动生成。还有一个需要注意的地方就是在使用<code>StreamRecords</code>的方法来构建<code>Record</code>时一定要记住用<code>withStreamKey</code>方法来指定<code>Stream Key</code>。</p><p>不管是消息或是消息ID，这些类基本都提供了扁平化的api来构造，使用起来还是很简单的。那么在构造了一个<code>Record</code>后怎么将其持久化到Redis的Stream类型中呢？</p><h3 id="向Stream添加消息（Record"><a href="#向Stream添加消息（Record" class="headerlink" title="向Stream添加消息（Record)"></a>向Stream添加消息（Record)</h3><p>使用<code>RedisTemplate</code>操作<code>Stream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String streamKey = <span class="string">"channel:stream:key1"</span>;<span class="comment">//stream key</span></span><br><span class="line">MailInfo mailInfo = <span class="keyword">new</span> MailInfo(<span class="string">"554205726@qq.com"</span>, <span class="string">"sendmail"</span>);</span><br><span class="line"></span><br><span class="line">ObjectRecord&lt;String, MailInfo&gt; record = ObjectRecord.create(streamKey, mailInfo);</span><br><span class="line"></span><br><span class="line">RecordId id = record.getId(); <span class="comment">//构造Record时使用的RecordId</span></span><br><span class="line">RecordId recordId = redisTemplate.opsForStream().add(record); <span class="comment">//返回的RecordId</span></span><br><span class="line"></span><br><span class="line">id.getTimestamp(); <span class="comment">//null</span></span><br><span class="line">id.getSequence(); <span class="comment">//null</span></span><br><span class="line">id.shouldBeAutoGenerated(); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">recordId.getTimestamp(); <span class="comment">//not null</span></span><br><span class="line">recordId.getSequence(); <span class="comment">//not null</span></span><br><span class="line">recordId.shouldBeAutoGenerated(); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>使用<code>add</code>方法来添加记录，该方法执行成功后返回添加的记录的<code>id</code>信息。注意下面的结果，这里有两个问题需要注意：</p><ol><li><p>为什么我们构造<code>Record</code>时使用的<code>RecordId</code>和添加记录返回的<code>RecordId</code>不同？</p><p>这个问题很好理解，因为构造<code>Record</code>时不指定<code>id</code>时虽然是自动生成，但是这个自动生成<strong>并不是</strong>在构造时就自动生成好了的，而是在执行Redis命令持久化时Redis服务器来自动生成的，所以前者在获取时间戳和序号的时返回<code>null</code>。</p></li><li><p>为什么添加记录返回的<code>RecordId</code>调用<code>shouldBeAutoGenerated</code>方法返回<code>false</code>呢，不是自动生成了吗？</p><p>其实也很好理解，因为在持久化一条Stream的记录时，我们可以指定<code>id</code>，也可以选择让Redis来自动生成，那么这也就导致<code>add</code>方法执行成功获取到Redis返回的<code>id</code>信息后在构造<code>RecordId</code>时<strong>并不知道</strong>返回的这个<code>id</code>是我们之前指定的还是Redis自动生成的，所以说前者返回<code>true</code>，后者返回<code>false</code>并不难理解。</p></li></ol><blockquote><p>说到这里，其实你去看一下<code>Record</code>构造时默认自动生成<code>id</code>是如何做到的就很好理解了。在这里稍微提一下：在构造<code>Record</code>时默认使用<code>RecordId.autoGenerate()</code>作为<code>RecordId</code>，而这个方法返回了一个匿名对象，这个匿名对象重写了上面那三个方法，前两个方法重写直接返回<code>null</code>，后者也就是<code>shouldBeAutoGenerated</code>方法返回<code>true</code>。</p></blockquote><h2 id="实现消息队列"><a href="#实现消息队列" class="headerlink" title="实现消息队列"></a>实现消息队列</h2><p>在基本了解了<code>SpringBoot2.2</code>新增的几个Stream操作api和相关类之后，也就到了我们Stream实现消息队列的实践部分了。为了方便，下面我会以发送邮件为例来讲一下如何使用Strean来实现消息队列。</p><p>为了方便后续的讲解，先构造一个简单的邮件信息类作为我们的消息内容：</p><figure class="highlight java"><figcaption><span>MailInfo.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造StreamMessageListenerContainer"><a href="#构造StreamMessageListenerContainer" class="headerlink" title="构造StreamMessageListenerContainer"></a>构造StreamMessageListenerContainer</h3><p>在使用<code>Pub/Sub</code>模式时，我们都是先创建一个<code>RedisMessageListenerContainer</code>容器，向这个容器注册监听器然后在<code>onMessage</code>方法中处理业务逻辑即可。那么使用<code>Stream</code>类型的话有没有提供一个类似的容器呢？答案是肯定的。在<code>SpringBoot2.2</code>提供了<code>StreamMessageListenerContainer</code>这个Stream类型专有的消息监听容器，而唯一的实现也就是<code>DefaultStreamMessageListenerContainer</code>。</p><p><code>StreamMessageListenerContainer</code>的构造函数相比<code>RedisMessageListenerContainer</code>多了一个<code>StreamMessageListenerContainerOptions</code>，这个对象是使用<code>builder</code>方式来创建的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StreamMessageListenerContainerOptions&lt;String, ObjectRecord&lt;String, MailInfo&gt;&gt; options =</span><br><span class="line">        StreamMessageListenerContainerOptions.builder()</span><br><span class="line">                .batchSize(<span class="number">100</span>) <span class="comment">//一批次拉取的最大count数</span></span><br><span class="line">                .executor(executor)  <span class="comment">//线程池</span></span><br><span class="line">                .pollTimeout(Duration.ZERO) <span class="comment">//阻塞式轮询</span></span><br><span class="line">                .targetType(MailInfo<span class="class">.<span class="keyword">class</span>) //目标类型（消息内容的类型）</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line">StreamMessageListenerContainer&lt;String, ObjectRecord&lt;String, MailInfo&gt;&gt; container =</span><br><span class="line">    StreamMessageListenerContainer.create(redisConnectionFactory, options);</span><br></pre></td></tr></table></figure><p>在构造<code>StreamMessageListenerContainerOptions</code>时最关键的就是<code>targetType</code>、<code>objectMapper</code>以及设置序列化器这几个方法，这些参数的设置会直接影响到后续接收到消息后能否反序列化为java对象！由于这部分内容涉及源码过多，在后面一部分我们再针对这几个方法进行详细的探查。</p><p>在构造完<code>StreamMessageListenerContainer</code>之后，现在该怎么注册消息监听器呢？我们接着往下看。</p><h3 id="注册StreamListener"><a href="#注册StreamListener" class="headerlink" title="注册StreamListener"></a>注册StreamListener</h3><p>在Pub/Sub模式中我们使用<code>addMessageListener(MessageListener, Topic)</code>方法添加一个<code>MessageListener</code>到指定的<code>Topic</code>，那么在使用Stream消息的监听容器时，我们是使用<code>receive</code>方法。</p><p><code>Spring-data-redis</code>提供了三个方法用于注册<code>StreamListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Subscription <span class="title">receive</span><span class="params">(StreamOffset&lt;K&gt; streamOffset, StreamListener&lt;K, V&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(StreamReadRequest.builder(streamOffset).build(), listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Subscription <span class="title">receive</span><span class="params">(Consumer consumer, StreamOffset&lt;K&gt; streamOffset, StreamListener&lt;K, V&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(StreamReadRequest.builder(streamOffset).consumer(consumer).autoAcknowledge(<span class="keyword">false</span>).build(), listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Subscription <span class="title">receiveAutoAck</span><span class="params">(Consumer consumer, StreamOffset&lt;K&gt; streamOffset, StreamListener&lt;K, V&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(StreamReadRequest.builder(streamOffset).consumer(consumer).autoAcknowledge(<span class="keyword">true</span>).build(), listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你发现你哪里<code>receive</code>方法和我的不太一样？那么你使用的版本应该是2.2，这个版本的问题比较多，比如上面这个地方，使用第二个方法注册<code>StreamListener</code>，在消息被消费之后会自动ack，因为<code>ConsumerStreamReadRequestBuilder</code>的<code>autoAck</code>属性默认就是<code>true</code>（除非使用第一个方法指定<code>StreamReadRequest</code>），这个问题在2.3修复了，感兴趣可以去看看这部分源码，修补提交<a href="https://github.com/spring-projects/spring-data-redis/commit/fccaeb23e99423b6ecca5dd023975a78c15c62ed#diff-879e58efc888ebee209566792c347c00" target="_blank" rel="noopener">在这里</a>。</p><blockquote><p>我个人最初就是使用的SpringBoot2.2.2，使用过程中发现<a href="https://jira.spring.io/projects/DATAREDIS/issues/DATAREDIS-1043?filter=allopenissues" target="_blank" rel="noopener">问题真的有点很多</a>。比如还有一处序列化器泛型类型错误导致<code>StreamMessageListenerContainerOptions</code>构造混乱的问题【<a href="https://github.com/spring-projects/spring-data-redis/commit/df720bde8fa3ccd811d010471440e07ce10b796c#diff-879e58efc888ebee209566792c347c00" target="_blank" rel="noopener">修补提交</a>】，所以说如果你想尝鲜，那么强烈建议使用<code>SpringBoot</code>最新发布的版本。</p></blockquote><h4 id="Consumer和StreamOffset"><a href="#Consumer和StreamOffset" class="headerlink" title="Consumer和StreamOffset"></a>Consumer和StreamOffset</h4><p>可以看到<code>receive</code>方法另外还需要<code>Consumer</code>和<code>StreamOffset</code>两个参数，</p><p><strong>Consumer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer.from(<span class="string">"group name"</span>, <span class="string">"consumer name"</span>)</span><br></pre></td></tr></table></figure><p><code>Consumer</code>表示消费者组中的某个消费者，这个东西只会在消费者组模式中用到。我们一般通过上面这种方式来创建，第一个参数表示消费者组，第二个参数表示消费者。</p><p><strong>StreamOffset</strong></p><p><code>StreamOffset</code>用于表示在某个Stream上的偏移量，它包含两部分内容，一个是stream的<code>key</code>，另一个是<code>ReadOffset</code>用于表示读取偏移量。前者应该不需要过多的解释，那么<code>ReadOffset</code>这个读取偏移量是干嘛用的呢？</p><p>要搞清楚<code>ReadOffset</code>，我们首先要知道Stream中偏移量的含义，在Stream中偏移量既可以表示消费记录时的偏移量，又可以表示消费者组在Stream上的偏移量。还记得Redis中我们怎么读取Stream中的记录吗？</p><p>通过<code>xread</code>命令也就是非消费者组模式直接读取，或者使用<code>xreadgroup</code>命令在消费者组中命令一个消费者去消费一条记录，这个时候，我们可以通过<code>0</code>、<code>&gt;</code>、<code>$</code>分别表示第一条记录、最后一次未被消费的记录和最新一条记录，这也就是<code>ReadOffset</code>的用途之一：<strong>用于表示直接读取或消费者组中消费者读取记录时的偏移量</strong>。</p><p>那么还有另外的用途吗？</p><p>当然了，还记得怎样创建消费者组吗？一般我们使用<code>xgroup create</code>命令创建一个消费者组时可以选择从Stream的第一条消息开始，或者Stream的中间某个记录开始，又或者从Stream的最新一条记录开始。也就分别代表了<code>0</code>、<code>$</code>。这也就是<code>ReadOffset</code>的用途之二：<strong>用于表示创建消费者组时该消费者组在Stream上的偏移量</strong>。</p><p>理解<code>ReadOffset</code>最快最简单的方法就是在Redis-cli中用Redis命令操作一番。这其中还有一些值得注意的问题，比如创建消费者组时不能使用<code>&gt;</code>表示最后一次未被消费的记录；比如<code>0</code>表示从第一条开始并且包括第一条；<code>$</code>表示从最新一条开始但并不是指当前Stream的最后一条记录，所以使用<code>$</code>时最新一条也就是表示下一个<code>xadd</code>添加的那一条记录，所以说<code>$</code>在非消费者组模式的阻塞读取下才有意义！</p><h3 id="实现StreamListener"><a href="#实现StreamListener" class="headerlink" title="实现StreamListener"></a>实现StreamListener</h3><p>同样的用Pub/Sub来类比，在Pub/Sub模式下我们实现的消息监听器是一般是<code>MessageListener</code>或者使用<code>MessageListenerAdapter</code>反射调用处理方法，在Strean消息队列的实现中必然也需要一个监听器用于处理真正的业务逻辑，这个类目前只有一个，也就是<code>StreamListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMessageListener</span> <span class="keyword">implements</span> <span class="title">StreamListener</span>&lt;<span class="title">String</span>, <span class="title">ObjectRecord</span>&lt;<span class="title">String</span>, <span class="title">MailInfo</span>&gt;&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(StreamMessageListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamMessageListener</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(ObjectRecord&lt;String, MailInfo&gt; message)</span> </span>&#123;</span><br><span class="line">        RecordId id = message.getId();</span><br><span class="line">        MailInfo messageValue = message.getValue();</span><br><span class="line">        logger.info(<span class="string">"消费stream:&#123;&#125;中的信息:&#123;&#125;, 消息id:&#123;&#125;"</span>, message.getStream(), messageValue, id);</span><br><span class="line">        <span class="comment">// 发邮件...</span></span><br><span class="line">        stringRedisTemplate.opsForStream().acknowledge(MAIL_GROUP, message); <span class="comment">//手动ack</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StreamListener</code>和<code>MessageListener</code>差不多，只需要实现<code>onMessage</code>方法，只不过多了个泛型参数罢了。在实现消息监听器后也就可以使用<code>receive</code>方法进行注册了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">container.receive(Consumer.from(MAIL_GROUP, <span class="string">"consumer-1"</span>),</span><br><span class="line">        StreamOffset.create(MAIL_CHANNEL, ReadOffset.lastConsumed()),</span><br><span class="line">        <span class="keyword">new</span> StreamMessageListener(stringRedisTemplate));</span><br></pre></td></tr></table></figure><p>注册完成之后启动<code>StreamMessageListenerContainer</code>容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.start();</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lolico Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamConsumerRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_CHANNEL = <span class="string">"channel:stream:mail"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_GROUP = <span class="string">"group:mail"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolTaskExecutor executor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StreamMessageListenerContainer&lt;String, ObjectRecord&lt;String, MailInfo&gt;&gt; container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamConsumerRunner</span><span class="params">(ThreadPoolTaskExecutor executor, RedisConnectionFactory redisConnectionFactory, StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="keyword">this</span>.redisConnectionFactory = redisConnectionFactory;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        StreamMessageListenerContainerOptions&lt;String, ObjectRecord&lt;String, MailInfo&gt;&gt; options =</span><br><span class="line">                StreamMessageListenerContainerOptions.builder()</span><br><span class="line">                        .batchSize(<span class="number">10</span>)</span><br><span class="line">                        .executor(executor)</span><br><span class="line">                        .pollTimeout(Duration.ZERO)</span><br><span class="line">                        .targetType(MailInfo<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                        .<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line">        StreamMessageListenerContainer&lt;String, ObjectRecord&lt;String, MailInfo&gt;&gt; container =</span><br><span class="line">                StreamMessageListenerContainer.create(redisConnectionFactory, options);</span><br><span class="line"></span><br><span class="line">        prepareChannelAndGroup(stringRedisTemplate.opsForStream(), MAIL_CHANNEL, MAIL_GROUP);</span><br><span class="line"></span><br><span class="line">        container.receive(Consumer.from(MAIL_GROUP, <span class="string">"consumer-1"</span>),</span><br><span class="line">                StreamOffset.create(MAIL_CHANNEL, ReadOffset.lastConsumed()),</span><br><span class="line">                <span class="keyword">new</span> StreamMessageListener(stringRedisTemplate));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">        <span class="keyword">this</span>.container.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareChannelAndGroup</span><span class="params">(StreamOperations&lt;String, ?, ?&gt; ops, String channel, String group)</span> </span>&#123;</span><br><span class="line">        String status = <span class="string">"OK"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StreamInfo.XInfoGroups groups = ops.groups(channel);</span><br><span class="line">            <span class="keyword">if</span> (groups.stream().noneMatch(xInfoGroup -&gt; group.equals(xInfoGroup.groupName()))) &#123;</span><br><span class="line">                status = ops.createGroup(channel, group);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            RecordId initialRecord = ops.add(ObjectRecord.create(channel, <span class="string">"Initial Record"</span>));</span><br><span class="line">            Assert.notNull(initialRecord, <span class="string">"Cannot initialize stream with key '"</span> + channel + <span class="string">"'"</span>);</span><br><span class="line">            status = ops.createGroup(channel, ReadOffset.from(initialRecord), group);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Assert.isTrue(<span class="string">"OK"</span>.equals(status), <span class="string">"Cannot create group with name '"</span> + group + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMessageListener</span> <span class="keyword">implements</span> <span class="title">StreamListener</span>&lt;<span class="title">String</span>, <span class="title">ObjectRecord</span>&lt;<span class="title">String</span>, <span class="title">MailInfo</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(StreamMessageListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StreamMessageListener</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(ObjectRecord&lt;String, MailInfo&gt; message)</span> </span>&#123;</span><br><span class="line">            RecordId id = message.getId();</span><br><span class="line">            MailInfo messageValue = message.getValue();</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">"消费stream:&#123;&#125;中的信息:&#123;&#125;, 消息id:&#123;&#125;"</span>, message.getStream(), messageValue, id);</span><br><span class="line"></span><br><span class="line">            stringRedisTemplate.opsForStream().acknowledge(MAIL_GROUP, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>prepareChannelAndGroup</code>方法，在初始化容器时，如果key对应的stream或者group不存在时会抛出异常，所以我们需要提前检查并且初始化。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>添加一个测试接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/sendMail"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;RecordId&gt; <span class="title">sendMail</span><span class="params">(String receiver, String description)</span> </span>&#123;</span><br><span class="line">    MailInfo mailInfo = <span class="keyword">new</span> MailInfo(receiver, description);</span><br><span class="line">    ObjectRecord&lt;String, MailInfo&gt; record = Record.of(mailInfo).withStreamKey(channel);</span><br><span class="line">    RecordId recordId = redisTemplate.opsForStream().add(record);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(recordId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问进行测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-06-28 19:26:17.870  INFO 21900 --- [         task-1] reamConsumerRunner$StreamMessageListener : 消费stream:channel:stream:mail中的信息:MailInfo(receiver&#x3D;534619360@qq.com, description&#x3D;发送邮件), 消息id:1593343576237-0</span><br></pre></td></tr></table></figure><p>控制台输出日志，如果在redis-cli中使用<code>xpending</code>命令检查ack信息会发现也是0，因为我们虽然使用<code>receive</code>方法注册，但是在<code>onMessage</code>中手动提交了确认，当然，你也可以使用<code>receiveAutoAck</code>方法添加。</p><h2 id="实践中踩到的坑"><a href="#实践中踩到的坑" class="headerlink" title="实践中踩到的坑"></a>实践中踩到的坑</h2><h3 id="自动ack和泛型类型错误"><a href="#自动ack和泛型类型错误" class="headerlink" title="自动ack和泛型类型错误"></a>自动ack和泛型类型错误</h3><p>这两个问题在前面已经提到了并且在2.3已经修复，这里不多说。还是那句话，如果想尝鲜，那么强烈推荐使用SpringBoot最新发布的版本。</p><h3 id="RedisTemplate序列化器使用错误导致容器无法反序列化"><a href="#RedisTemplate序列化器使用错误导致容器无法反序列化" class="headerlink" title="RedisTemplate序列化器使用错误导致容器无法反序列化"></a>RedisTemplate序列化器使用错误导致容器无法反序列化</h3><p><code>RedisTemplate</code>的hashvalue的序列化器最初使用的json序列化器，导致容器监听到新消息反序列化时抛出异常：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Value must not be null!</span><br><span class="line">    at org.springframework.util.Assert.notNull(Assert.java:198)</span><br><span class="line">    at org.springframework.data.redis.connection.stream.Record.of(Record.java:81)</span><br><span class="line">    at org.springframework.data.redis.connection.stream.MapRecord.toObjectRecord(MapRecord.java:147)</span><br><span class="line">    at org.springframework.data.redis.core.StreamObjectMapper.toObjectRecord(StreamObjectMapper.java:132)</span><br><span class="line">    at org.springframework.data.redis.core.StreamObjectMapper.map(StreamObjectMapper.java:158)</span><br><span class="line">    at org.springframework.data.redis.core.StreamOperations.read(StreamOperations.java:458)</span><br><span class="line">    at org.springframework.data.redis.stream.DefaultStreamMessageListenerContainer.lambda$getReadFunction$2(DefaultStreamMessageListenerContainer.java:232)</span><br><span class="line">    at org.springframework.data.redis.stream.StreamPollTask.doLoop(StreamPollTask.java:138)</span><br><span class="line">    at org.springframework.data.redis.stream.StreamPollTask.run(StreamPollTask.java:123)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>这是为什么呢？我们知道Redis中Stream中存的是键值对并且<code>DefaultStreamOperations</code>中操作的都是<code>byte[]</code>，也就是说我们虽然添加的是<code>ObjectRecord</code>，但是会先转换成<code>MapRecord</code>，然后再被转换成<code>ByteRecord</code>，最后进行序列化。来看一下<code>add</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RecordId <span class="title">add</span><span class="params">(Record&lt;K, ?&gt; record)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(record, <span class="string">"Record must not be null"</span>);</span><br><span class="line">    MapRecord&lt;K, HK, HV&gt; input = StreamObjectMapper.toMapRecord(<span class="keyword">this</span>, record); <span class="comment">//转换成MapRecord</span></span><br><span class="line">    ByteRecord binaryRecord = input.serialize(keySerializer(), hashKeySerializer(), hashValueSerializer()); <span class="comment">//再使用序列化器转换成ByteRecord</span></span><br><span class="line">    <span class="keyword">return</span> execute(connection -&gt; connection.xAdd(binaryRecord), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这个方法我们可以发现stream序列化时和其他类型不一样，我们在使用json序列化一个对象时都是直接进行的，而这里分了两步并且序列化器是用于第二部转换，那么<code>ObjectRecord</code>是怎么转换成<code>MapRecord</code>的呢？点进<code>StreamObjectMapper.toMapRecord</code>方法可以看到其实是通过<code>ObjectRecord#toMapRecord</code>方法完成的，这个方法需要一个<code>HashMapper</code>用于将对象的属性/属性值映射构造成Map类型，你会发现<code>opsForStream</code>方法重载了一个默认无参的方法，而这个方法默认使用的是<code>ObjectHashMapper</code>，在我们构造<code>StreamMessageListenerContainerOptionsBuilder</code>时调用<code>targetType</code>时默认使用的也是<code>ObjectHashMapper</code>。而这个<code>ObjectHashMapper</code>会将对象中的属性和属性值转换成<code>byte[]</code>形式，所以在第一步之后这个<code>MapRecord</code>中的值的类型已经是<code>byte[]</code>了，那么也就导致第二步在使用json序列化器转换为<code>ByteRecord</code>时出现这种情况：<code>objectMapper.writeValueAsBytes(byte[])</code>，这是一个测试实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="keyword">byte</span>[] value = <span class="string">"534619360@qq.com"</span>.getBytes();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = mapper.writeValueAsBytes(value);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">    <span class="comment">//输出"NTM0NjE5MzYwQHFxLmNvbQ=="</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反应到stream中值就变成了\“NTM0NjE5MzYwQHFxLmNvbQ==\“（引号需要转义）。为了便于理解，我们可以使用设置使用json序列化器的<code>RedisTemplate</code>进行<code>add</code>断点debug测试看一下转换后的两个<code>Record</code>中的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringRedisTemplate.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line">    MailInfo mailInfo = <span class="keyword">new</span> MailInfo(<span class="string">"534619360@qq.com"</span>, <span class="string">"send mail"</span>);</span><br><span class="line">    stringRedisTemplate.opsForStream().add(Record.of(mailInfo).withStreamKey(channel));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试并断点查看<code>MapRecord</code>和<code>ByteRecord</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200628204658.png" alt=""></div><div class="image-caption"></div></figure><p>使用Redis Desktop Manager查看值：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200628204930.png" alt=""></div><div class="image-caption"></div></figure><p>测试结束终端抛出上面提到的异常。这个问题解决办法就是使用<code>String</code>序列化器也就是使用<code>StringRedisTemplate</code>，因为这个序列化器不能序列化<code>byte[]</code>类型的对象，使用这个序列化器在序列化时如果已经是<code>byte[]</code>，那么就会直接返回原<code>byte[]</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200628210421.png" alt=""></div><div class="image-caption"></div></figure><p>更具体的细节可以跟着<code>add</code>方法debug一遍。</p><h3 id="ReadOffset使用错误导致group中消费者消费失败"><a href="#ReadOffset使用错误导致group中消费者消费失败" class="headerlink" title="ReadOffset使用错误导致group中消费者消费失败"></a>ReadOffset使用错误导致group中消费者消费失败</h3><p>异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RedisCommandExecutionException: ERR The $ ID is meaningless in the context of XREADGROUP: you want to read the history of this consumer by specifying a proper ID, or use the &gt; ID to get new messages. The $ ID would just return an empty result set.</span><br></pre></td></tr></table></figure><p>上面<code>StreamOffset</code>中也提到了，这涉及到<code>0</code>、<code>&gt;</code>、<code>$</code>的使用场景和范围，如果出现这个异常，很有可能你在消费者组模式下设置消费者读取的offset时使用了<code>ReadOffset.latest()</code>，而这个对应着<code>$</code>，也就是最新一条记录。如果不明白那么你可能对这三个标识符的使用还不是很理解，最好的解决办法就是使用redis命令先完整的操作一遍。</p><h3 id="stream或者group不存在导致启动抛出异常"><a href="#stream或者group不存在导致启动抛出异常" class="headerlink" title="stream或者group不存在导致启动抛出异常"></a>stream或者group不存在导致启动抛出异常</h3><p>同样在上面提到了，在构造<code>StreamMessageListenerContainer</code>时需要stream和group存在才可以。解决方法就是提前检查并初始化，上面已给出代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实在实践之初，我在网上也搜了很多相关的资料，但是发现这些资料基本都是使用redis-cli进行命令上的操作，并没有<code>SpringBoot</code>中实现。这次实践可谓是艰辛，由于目前该支持的迭代次数比较少，不乏一些bug或者小问题（2.3已经比较稳定），并且只有<code>lettuce</code>提供了stream类型的操作实现，而<code>lettuce</code>本身又有些小毛病，这些因素结合在一起也就导致这个过程花费了我整整两天时间，而这篇博客又花了整整一下午的时间才算完成，其中可能有些内容因为涉及东西比较多只能粗略提一下，并且语言组织上不太好可能不好去理解。话说回来，这篇文章也算是我自己实践后的一个个人总结吧，这个过程其实学到的东西还是很多的，也不枉费花了这么多时间。如果你发现文章有什么地方有问题或者有什么地方不理解，也欢迎在评论区留言一起交流~</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://lolico.me/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://lolico.me/tags/SpringBoot/"/>
    
      <category term="Redis" scheme="https://lolico.me/tags/Redis/"/>
    
      <category term="MQ" scheme="https://lolico.me/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>单文件发布时${basedir}无效导致文件日志无法写入的问题</title>
    <link href="https://lolico.me/2020/06/20/Why-cannot-write-log-to-files-when-wpf-application-publishing-as-a-single-file/"/>
    <id>https://lolico.me/2020/06/20/Why-cannot-write-log-to-files-when-wpf-application-publishing-as-a-single-file/</id>
    <published>2020-06-20T04:51:36.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>还是<code>NLog</code>问题，虽然<code>NLog</code>上手简单，配置容易，但是在<code>NetCore3</code>下还是有一些坑的，虽然这不是<code>NLog</code>的问题。因为这个问题百度一圈都无果，所以在这里记录一下，希望可以帮助到百度的同学（虽然这个站点没有提交到百度收录？逃~</p><h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>好，那么现在回到主题。前一阵子在用<code>WPF</code>来做一个<code>First</code>、<code>Follow</code>集算法模拟的工具，项目中使用<code>NLog</code>记录日志，在<code>NetCore 3.1</code>下作为单文件发布。发布后<code>File</code>类型的日志<code>target</code>没有将日志如期写入到文件中。并且仅在单文件发布并且<code>fileName</code>使用相对路径或者<code>${basedir}</code>指定基础目录时，才会出现这个问题，其实这个问题的解决方法很简单，只需稍微改一下就可以解决。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用<code>${basedir:fixtempdir=true}</code>指定基础目录。</p><p>这个问题主要原因其实是<code>NetCore3</code>单文件发布时<code>AppDomain.BaseDirectory</code>无法正确引用基础路径的问题，并且微软并没有打算在<code>NetCore3</code>修复这个问题，或许<code>NetCore5</code>会修复这个问题吧，文末会放几个链接，感兴趣可以去看看。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>又水了一篇文章，最近文章质量有点差，上个月还鸽掉了一篇Aop详解的文章（其实一直都在<code>draft</code>中），感觉有点罪恶感 :D</p><hr><p><em>参考：</em></p><ul><li><a href="https://github.com/dotnet/aspnetcore/issues/12621" target="_blank" rel="noopener">PublishSingleFile excluding appsettings not working as expected</a></li><li><a href="https://github.com/dotnet/runtime/issues/3704" target="_blank" rel="noopener">Single file publish: AppContext.BaseDirectory doesn’t point to apphost directory</a></li><li><a href="https://github.com/NLog/NLog/issues/3808" target="_blank" rel="noopener">When .net core app published as single file - ${basedir} is wrong</a></li><li><a href="https://stackoverflow.com/questions/62445319/why-cannot-write-log-to-files-when-wpf-application-publishing-as-a-single-file/62456300#62456300" target="_blank" rel="noopener">Why cannot write log to files when WPF application publishing as a single file</a></li><li><a href="https://github.com/nlog/nlog/wiki/Basedir-Layout-Renderer" target="_blank" rel="noopener">Basedir layout renderer</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="WPF" scheme="https://lolico.me/tags/WPF/"/>
    
      <category term="NLog" scheme="https://lolico.me/tags/NLog/"/>
    
      <category term=".Net Core 3" scheme="https://lolico.me/tags/Net-Core-3/"/>
    
  </entry>
  
  <entry>
    <title>Asp.Net Core中使用NLog日志时NLog路由不生效只输出Info级别日志的问题</title>
    <link href="https://lolico.me/2020/06/16/Why-the-log-level-does-not-take-effect-when-using-NLog-in-Asp-Net-Core-application/"/>
    <id>https://lolico.me/2020/06/16/Why-the-log-level-does-not-take-effect-when-using-NLog-in-Asp-Net-Core-application/</id>
    <published>2020-06-16T13:44:44.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>在一次将<code>Asp.net Core</code>默认日志换成<code>NLog</code>时，发现<code>NLog</code>配置文件中的设置不生效？具体的来说就是在<code>NLog</code>文件中设置的路由以及对应的日志级别只有在<code>Info</code>或者以上时才生效，而<code>Debug</code>、<code>Trace</code>级别则不会有日志输出。比如我的<code>NLog</code>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nlog</span> <span class="attr">xmlns</span>=<span class="string">"http://www.nlog-project.org/schemas/NLog.xsd"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.nlog-project.org/schemas/NLog.xsd NLog.xsd"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">autoReload</span>=<span class="string">"true"</span> <span class="attr">throwExceptions</span>=<span class="string">"false"</span> <span class="attr">throwConfigExceptions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">internalLogLevel</span>=<span class="string">"Warn"</span> <span class="attr">internalLogFile</span>=<span class="string">"$&#123;basedir&#125;/logs/internal.log"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"logDirectory"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/logs"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">assembly</span>=<span class="string">"NLog.Web.AspNetCore"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">targets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-wrapper</span> <span class="attr">xsi:type</span>=<span class="string">"BufferingWrapper"</span> <span class="attr">bufferSize</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">xsi:type</span>=<span class="string">"File"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;logDirectory&#125;/$&#123;shortdate&#125;-$&#123;level&#125;.log"</span> <span class="attr">encoding</span>=<span class="string">"utf-8"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">layout</span>=<span class="string">"$&#123;longdate&#125;|$&#123;uppercase:$&#123;level&#125;&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">targets</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">targets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-wrapper</span> <span class="attr">xsi:type</span>=<span class="string">"AsyncWrapper"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">wrapper-target</span> <span class="attr">xsi:type</span>=<span class="string">"RetryingWrapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-wrapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">xsi:type</span>=<span class="string">"ColoredConsole"</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">detectConsoleAvailable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">layout</span>=<span class="string">"$&#123;longdate&#125;|$&#123;uppercase:$&#123;level&#125;&#125;|$&#123;logger&#125;|$&#123;message&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">targets</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"Microsoft.*"</span> <span class="attr">minlevel</span>=<span class="string">"Debug"</span> <span class="attr">writeTo</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"WebApplication.*"</span> <span class="attr">minlevel</span>=<span class="string">"Trace"</span> <span class="attr">writeTo</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">minlevel</span>=<span class="string">"Info"</span> <span class="attr">writeTo</span>=<span class="string">"file"</span> <span class="attr">final</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">nlog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照<code>rules</code>中的设置，<code>Microsoft</code>命名空间下<code>Debug</code>级别的日志应该都可以输出在控制台中的，但是启动后控制台的输出只有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-06-16 20:41:34.9142|INFO|Microsoft.Hosting.Lifetime|Now listening on: https:&#x2F;&#x2F;localhost:5001</span><br><span class="line">2020-06-16 20:41:34.9353|INFO|Microsoft.Hosting.Lifetime|Now listening on: http:&#x2F;&#x2F;localhost:5000</span><br><span class="line">2020-06-16 20:41:34.9353|INFO|Microsoft.Hosting.Lifetime|Application started. Press Ctrl+C to shut down.</span><br><span class="line">2020-06-16 20:41:34.9353|INFO|Microsoft.Hosting.Lifetime|Hosting environment: Development</span><br><span class="line">2020-06-16 20:41:34.9353|INFO|Microsoft.Hosting.Lifetime|Content root path: D:\workspace\csharp\WebApplication\WebApplication</span><br></pre></td></tr></table></figure><p>注意这里的格式已经应用了<code>NLog</code>中设置的布局，这说明配置文件被加载了并没有问题，但为什么日志级别的设置不生效呢？</p><h2 id="原因所在"><a href="#原因所在" class="headerlink" title="原因所在"></a>原因所在</h2><p>其实是因为<code>appsettings.{env}.json</code>中日志级别的设置覆盖了<code>Nlog</code>中的设置。在我们创建一个<code>Asp.Net Core</code>项目时，一般会帮我们创建好两个<code>appsettings.json</code>文件：</p><figure class="highlight json"><figcaption><span>appsettings.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">      <span class="attr">"Default"</span>: <span class="string">"Information"</span>,</span><br><span class="line">      <span class="attr">"Microsoft"</span>: <span class="string">"Warning"</span>,</span><br><span class="line">      <span class="attr">"Microsoft.Hosting.Lifetime"</span>: <span class="string">"Information"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"AllowedHosts"</span>: <span class="string">"*"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><figcaption><span>appsettings.Development.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">      <span class="attr">"Default"</span>: <span class="string">"Information"</span>,</span><br><span class="line">      <span class="attr">"Microsoft"</span>: <span class="string">"Warning"</span>,</span><br><span class="line">      <span class="attr">"Microsoft.Hosting.Lifetime"</span>: <span class="string">"Information"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意这里使用.net core3.1创建的模板，2.1创建的项目命名空间以及对应日志级别会有所不同。</p></blockquote><p>从这两个文件很容易发现默认的日志级别为<code>Information</code>并且<code>Microsoft</code>命名空间下的日志级别被设置成了<code>Warning</code>，当然也就覆盖了<code>NLog</code>中的设置，为什么会覆盖呢？可以思考一下。并且这里的设置能够影响到<code>NLog</code>中的设置还有一个前提：将<code>NLog</code>添加到容器，并且是以<code>DI</code>的方式来获取<code>ILogger</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Host.CreateDefaultBuilder(args)</span><br><span class="line">        .ConfigureLogging(logBuilder =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            logBuilder.ClearProviders()</span><br><span class="line">            .AddNLog(<span class="string">"NLog.config"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .ConfigureWebHostDefaults(webBuilder =&gt; webBuilder.UseStartup&lt;Startup&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你是这样添加<code>NLog</code>，然后使用<code>DI</code>在需要记录日志的类中注入<code>ILogger</code>的话，那很可能就中招了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> NLog.Logger _logger = NLog.LogManager.GetCurrentClassLogger();</span><br></pre></td></tr></table></figure><p>如果你不使用<code>DI</code>来注入而是使用上面这个方式来获取<code>logger</code>，那么就不存在这个问题。但是我们使用容器主要的目的不就是容器可以更方便的管理对象之间的依赖吗？更具体地说那就是<code>DI</code>。那这个问题该怎样解决呢？</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决的方法其实很简单：</p><p>首先删除<code>appsettings.{env}.json</code>中日志相关的设置，然后在注册<code>NLog</code>时设置最低日志级别为你所用到的最低级别（因为就算去掉了这些设置，默认的日志级别也是<code>Information</code>），这样一来，就相当于把日志级别控制和输出都交给<code>NLog</code>来管理。比如我上面的文件中给自己项目的命名空间设置了<code>Trace</code>并且已是最低级别，那么在删除<code>appsettings.{env}.json</code>中日志相关的设置后可以这样来添加<code>NLog</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Host.CreateDefaultBuilder(args)</span><br><span class="line">        .ConfigureLogging(logBuilder =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            logBuilder.ClearProviders()</span><br><span class="line">            .SetMinimumLevel(LogLevel.Trace) <span class="comment">// 最低为Trace</span></span><br><span class="line">            .AddNLog(_configFileRelativePath);</span><br><span class="line">        &#125;)</span><br><span class="line">        .ConfigureWebHostDefaults(webBuilder =&gt; webBuilder.UseStartup&lt;Startup&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者你也可以使用<code>AddFilter</code>来细分使得日志输出可以“交到”<code>NLog</code>手中。当然，如果你不想删除原有的设置并且不想通过<code>SetMinimumLevel(LogLevel)</code>方法来设置最低级别，你也可以在<code>appsettings.{env}.json</code>文件中设置命名空间和相应的日志级别来保证<code>NLog</code>中的设置不会被覆盖（因为这个文件在启动时会自动被加载）。总之，只需要保证<code>NLog</code>中日志级别的设置不会因为该文件或者默认的<code>Information</code>级别所覆盖即可。如果不使用<code>DI</code>来获取的话那就当我没说。（逃</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class=&quot;headerlink&quot; title=&quot;问题
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Asp.Net Core" scheme="https://lolico.me/tags/Asp-Net-Core/"/>
    
      <category term="NLog" scheme="https://lolico.me/tags/NLog/"/>
    
  </entry>
  
  <entry>
    <title>部署Asp.Net Core应用并使用Nginx反代时遇到的两个问题</title>
    <link href="https://lolico.me/2020/06/12/Two-problems-encountered-when-deploying-Asp-Net-Core-application-and-using-Nginx-to-reverse-proxy/"/>
    <id>https://lolico.me/2020/06/12/Two-problems-encountered-when-deploying-Asp-Net-Core-application-and-using-Nginx-to-reverse-proxy/</id>
    <published>2020-06-12T12:08:19.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><p>在一次部署Asp.Net Core应用时遇到了这么几个问题：</p><ol><li>启动应用后，从<code>IConfiguration</code>中获取不到连接字符串。</li><li>使用nginx反代后，<code>Identity</code>框架页面跳转后域名被改写成了<code>localhost</code>或者<code>主机名</code>。</li></ol><p><strong>问题一：</strong></p><p>应用使用sqlite数据库，在程序启动后创建并初始化数据库，本地开发启动并没有报错，但是部署到服务器却获取不到连接字符串，报错：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200612191218.png" alt=""></div><div class="image-caption"></div></figure><p>百度和谷歌都无果，最初我还以为是程序中某个地方可能出错了，但是在WSL上经过多次测试，发现如果没有在执行文件的目录下启动了项目才会报这样的错误，这个问题很奇怪，猜测是<code>Directory.GetCurrentDirectory()</code>获取路径导致，并未求证。知道了问题所在那么解决的办法就很简单了，<code>cd</code>到执行文件目录启动即可。</p><p><strong>问题二：</strong></p><p>这个问题是宝塔面板导致的，在设置反代的发送域名后，并没有反应到配置文件中，也就是说在面板上设置<code>proxy_set_header Host $host;</code>后文件中并没有改过来，依旧是<code>localhost</code>或者<code>$hostname</code>，也就导致了页面跳转时域名变成了<code>localhost</code>或者<code>主机名</code>。解决的办法很简单，只需要手动修改nginx配置文件中的反代发送域名即可。</p><p>在这之前，其实还遇到了一个和nginx反代相关的问题：如果使用nginx来代理目录，从而实现一个域名下部署多个项目，这样做之后就导致Asp.net Core应用全部404，网上搜索一番，有些类似的问题解答提到使用<code>Microsoft.AspNetCore.HttpOverrides</code>包，但是我照着操作一番后依旧没用，目前比较笨的解决办法就是mvc的路由前手动加前缀，更好的办法目前没有找到，如果你知道，还请评论告知~</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;在一次部署Asp.Net Core应用时遇到了这么几个问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;启动应用后，从&lt;code&gt;
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Asp.Net Core" scheme="https://lolico.me/tags/Asp-Net-Core/"/>
    
      <category term="Nginx" scheme="https://lolico.me/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>解决JetBrains产品中无法使用非商店发行版本的WSL的问题</title>
    <link href="https://lolico.me/2020/05/19/Using-custom-WSL-in-jetbrains-product/"/>
    <id>https://lolico.me/2020/05/19/Using-custom-WSL-in-jetbrains-product/</id>
    <published>2020-05-19T09:48:45.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><p>JetBrains产品对于WSL提供了一定的支持，但是其只支持Microsoft Store中发行的WSL，对于类似<a href="https://github.com/yuk7/ArchWSL" target="_blank" rel="noopener">ArchWSL</a>这种非商店发行版，在配置工具链时却不能够被发现。下面给出两个方法来解决这个问题。</p><blockquote><p>由于我目前只使用过<a href="https://github.com/yuk7/ArchWSL" target="_blank" rel="noopener">ArchWSL</a>这个非商店发行版的WSL，所以下面以ArchWSL为例，对于其他版本的WSL，理论上也行得通。</p></blockquote><ol><li><p>第一种方法很简单，只需要复制执行文件到指定目录</p><p>只需将<code>Arch.exe</code>文件拷贝一份到<code>C:\Users\lolico\AppData\Local\Microsoft\WindowsApps</code>目录下即可。</p><p><em>注意，如果你安装了多个Arch，在拷贝时需要将每个版本对应的执行文件都拷贝到<code>WindowsApps</code>目录下。</em></p></li><li><p>第二种方法是网上搜索到的一个方法，并且在<a href="https://www.jetbrains.com/help/ruby/configuring-remote-interpreters-using-wsl.html#custom_wsl" target="_blank" rel="noopener">RubyMine官方文档</a>中提到了这个方法</p><p>以RubyMine为例，修改<code>wsl.distributions.xml</code>文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">descriptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>Arch<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">microsoft-id</span>&gt;</span>Arch<span class="tag">&lt;/<span class="name">microsoft-id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executable-path</span>&gt;</span>Arch.exe<span class="tag">&lt;/<span class="name">executable-path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">presentable-name</span>&gt;</span>Arch Linux<span class="tag">&lt;/<span class="name">presentable-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>executable-path</code>使用执行文件的绝对路径。</li><li><code>wsl.distributions.xml</code>文件位于产品对应的配置文件夹下，对于不同版本，配置文件夹位置可能不一样。</li></ul><blockquote><p>旧版本软件的配置文件夹在<code>%HOMEPATH%</code>下，此时该文件位于配置文件夹下的<code>config\options</code>目录中。在2020.1版本，配置文件夹迁移到了<code>%HOMEPATH%\AppData\Roaming\JetBrains</code>下，此时该文件位于配置文件夹下的<code>options</code>目录中。由于我一直使用ToolBox来安装并管理这些软件，所以说如果你并不是从ToolBox中安装的软件，新版本的配置文件夹可能仍然在<code>%HOMEPATH%</code>下。</p></blockquote></li></ol><p>最后，还想说一句，在使用商店发行版时我们可以用类似<code>\\wsl$\Ubuntu</code>这种路径来访问WSL的根目录，在使用非商店发行版时却不行，解决的办法还是上面提到第一个方法，拷贝文件到<code>WindowsApps</code>之后即可使用<code>\\wsl$\Arch</code>来访问Arch的根目录。</p><hr><p><em>参考：</em></p><p>^ <a href="https://www.jetbrains.com/help/ruby/configuring-remote-interpreters-using-wsl.html#custom_wsl" target="_blank" rel="noopener"><em>Custom WSL distributions</em></a><br>^ <a href="https://youtrack.jetbrains.com/issue/Py-32424#focus=streamItem-27-3332472.0-0" target="_blank" rel="noopener"><em>Support custom WSL distributive (not from Microsoft Store)</em></a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;JetBrains产品对于WSL提供了一定的支持，但是其只支持Microsoft Store中发行的WSL，对
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="WSL" scheme="https://lolico.me/tags/WSL/"/>
    
      <category term="IDEA" scheme="https://lolico.me/tags/IDEA/"/>
    
      <category term="WebStorm" scheme="https://lolico.me/tags/WebStorm/"/>
    
      <category term="PyCharm" scheme="https://lolico.me/tags/PyCharm/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 2.x AOP默认使用CGLIB代理</title>
    <link href="https://lolico.me/2020/05/03/SpringBoot2-AOP-uses-cglib-proxy-by-default/"/>
    <id>https://lolico.me/2020/05/03/SpringBoot2-AOP-uses-cglib-proxy-by-default/</id>
    <published>2020-05-03T11:18:32.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><p>在一次偶然情况下发现SpringBoot开发的应用在没有使用<code>@EnableAspectJAutoProxy</code>注解的情况下，AOP还是可以正常工作。不经引起了我的注意，随后便猜测SpringBoot中是否存在一个自动配置类在不使用注解的情况下完成自动配置并开启了AOP。</p><a id="more"></a><p>在Idea中尝试搜索<code>AopAutoConfiguration</code>，果然不出所料，有这么一个自动配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"auto"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Advice<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line">        <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>,</span><br><span class="line">                matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">jdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line">        <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">                matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>@ConditionalOnProperty</code>注解中<code>matchIfMissing</code>属性的设置，也正是这个属性的设置使得我们在不使用<code>@EnableAspectJAutoProxy</code>注解开启AOP的情况下，AOP也可以正常工作。</p><p>从这个自动配置类中还能够看出AOP默认使用Cglib代理。那么如果我们使用<code>@EnableAspectJAutoProxy</code>注解去指定默认不使用Cglib代理，有没有用呢？</p><p>经过测试发现，使用<code>@EnableAspectJAutoProxy</code>注解显示指定是没有用的。那么该如何设置默认使用jdk动态代理呢？根据自动配置类能知道，我们只需要在<code>application.properties</code>中指定<code>spring.aop.proxy-target-class=false</code>或者设置<code>spring.aop.auto=false</code>关闭aop自动配置后自行使用<code>@EnableAspectJAutoProxy</code>注解进行设置。</p><p>并且如果查看SpringBoot1.5.x中的这个自动配置类会发现默认是使用jdk动态代理，那么为什么在SpringBoot2.x中改为默认使用Cglib了呢？</p><blockquote><p>使用jdk动态代理会存在一个代理问题：目标对象一定要实现接口。因为jdk动态代理是基于接口的，并且意味着当使用<code>@Autowired</code>注入一个使用jdk代理生成的对象时必须使用接口。</p></blockquote><p>就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure><p>一旦使用实现类的方式进行注入就会失败：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserServiceImpl userService;</span><br></pre></td></tr></table></figure><p>使用Cglib代理就不存在这个问题，原因就在于Cglib是使用子类的方式进行代理。</p><p>当查看类似<code>@EnableCaching</code>、<code>@EnableAsync</code>、<code>@EnableTransactionManagement</code>注解中<code>proxyTargetClass</code>属性的注释，我们还会发现注释中说到，这个属性设置为true后会影响Spring管理的所有Bean使用的代理方式。但是我经过测试发现其他注解的这个属性设置为true时并不会影响<code>@EnableAsync</code>的代理方式。但是<code>@EnableAsync</code>的这个属性设置为true后会影响其他注解下对象的代理方式。(SpringBoot2.2.2下测试)</p><p>注意：<code>proxyTargetClass</code>属性默认为false时并不意味着如果目标对象没有实现接口，生成代理类就会失败，这种情况下Spring会使用Cglib代理。</p><hr><p><em>参考：</em></p><p>^ <a href="https://github.com/spring-projects/spring-boot/issues/5423" target="_blank" rel="noopener"><em>Use @EnableTransactionManagement(proxyTargetClass = true)</em></a><br>^ <a href="https://github.com/spring-projects/spring-boot/issues/8434" target="_blank" rel="noopener"><em>@EnableTransactionManagement proxyTargetClass not control by spring.aop.proxyTargetClass</em></a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;在一次偶然情况下发现SpringBoot开发的应用在没有使用&lt;code&gt;@EnableAspectJAutoProxy&lt;/code&gt;注解的情况下，AOP还是可以正常工作。不经引起了我的注意，随后便猜测SpringBoot中是否存在一个自动配置类在不使用注解的情况下完成自动配置并开启了AOP。&lt;/p&gt;
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://lolico.me/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://lolico.me/tags/SpringBoot/"/>
    
      <category term="AOP" scheme="https://lolico.me/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity 跨域</title>
    <link href="https://lolico.me/2020/04/26/Spring-Security-CORS/"/>
    <id>https://lolico.me/2020/04/26/Spring-Security-CORS/</id>
    <published>2020-04-26T16:01:12.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在SpringSecurity中配置跨域，我相信所有用过SpringSecurity的人应该都知道，因为实在是太简单了。那我为什么还要写这篇文章呢？写这篇文章的目的当然不是去解释如何配置跨域，而是通过分析Spring对跨域支持的源码来感受设计中的优雅。</p><p>先声明一下开发环境：<code>SpringBoot：2.2.2</code></p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>既然说到SpringSecurity配置跨域，那么我们就先简单复习一下如何配置跨域。</p><h3 id="配置跨域"><a href="#配置跨域" class="headerlink" title="配置跨域"></a>配置跨域</h3><p>我们都知道集成SpringSecurity后配置跨域我们只需要在继承<code>WebSecurityConfigurerAdapter</code>类，重写<code>configure(HttpSecurity http)</code>方法，开启<code>cors</code>并提供一个跨域配置源即可。下面是一个例子：</p><figure class="highlight java"><figcaption><span>开启跨域</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.sessionManagement()</span><br><span class="line">            .sessionCreationPolicy(SessionCreationPolicy.STATELESS) <span class="comment">// 前后端分离</span></span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable() <span class="comment">// 禁用csrf</span></span><br><span class="line">            .cors(); <span class="comment">// 跨域</span></span><br><span class="line">    <span class="comment">// ... 省略其他配置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提供一个CorsConfigurationSource</span></span><br><span class="line"><span class="comment">// 这里直接注册成Bean即可，注意方法名必须是corsConfigurationSource，后面会解释</span></span><br><span class="line"><span class="comment">// 也可以cors().configurationSource(corsConfigurationSource())指定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CorsConfigurationSource <span class="title">corsConfigurationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CorsConfiguration configuration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">    configuration.addAllowedOrigin(<span class="string">"*"</span>); <span class="comment">// 根据实际的需要去设置</span></span><br><span class="line">    configuration.addAllowedMethod(<span class="string">"*"</span>); <span class="comment">// 同上</span></span><br><span class="line">    configuration.addAllowedHeader(<span class="string">"*"</span>); </span><br><span class="line">    configuration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line">    configuration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">"/**"</span>, configuration);</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就如前面所说，只需要开启<code>cors</code>再提供一个跨域配置源即可。方法很简单，但这里有个坑需要注意一下。</p><h4 id="暴露公共接口时跨域的一个坑"><a href="#暴露公共接口时跨域的一个坑" class="headerlink" title="暴露公共接口时跨域的一个坑"></a>暴露公共接口时跨域的一个坑</h4><blockquote><p>如果我们还重写了<code>configure(WebSecurity web)</code>方法，使用<code>web.ignoring().antMatchers(ignorePaths)</code>去暴露一个公共接口’/pub’那么上面的跨域配置对这个接口来说就没用，也就是说这个接口会出现跨域问题。然而我们原本就是为了提供公共接口’/pub’，但现在却有跨域问题，那怎么能行！！！（一般来说这个方法是对静态资源设置直接放行，而不是公共接口！）</p></blockquote><p><em>那这到底是为什么呢？</em></p><p><strong>因为SpringSecurity配置跨域支持，是通过<code>CorsFilter</code>过滤器来实现的</strong>，我们<code>web.ignoring()</code>中设置后对应的接口请求就不会经过<code>CorsFilter</code>来处理，这个接口当然就存在跨域问题了！之所以说<em>这个方法是对静态资源设置直接放行，而不是公共接口</em>也是这个原因，那正确的方法是什么呢？还是<code>configure(HttpSecurity http)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.sessionManagement()</span><br><span class="line">            .sessionCreationPolicy(SessionCreationPolicy.STATELESS) <span class="comment">// 前后端分离</span></span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable() <span class="comment">// 禁用csrf</span></span><br><span class="line">            .cors() <span class="comment">// 跨域</span></span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">"/pub/**"</span>).permitAll() <span class="comment">// 匿名通过认证</span></span><br><span class="line">            .anyRequest().authenticated() <span class="comment">//剩下的任何请求都需要认证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cors方法"><a href="#cors方法" class="headerlink" title="cors方法"></a>cors方法</h3><p>现在我们来看一下<code>cors()</code>方法，点进这个方法看看，其实很简单，就是应用了一个<code>CorsConfigurer</code>配置类。如果看过<code>SpringSecurity</code>自动配置，对形如<code>xxxConfigurer</code>的类名应该不陌生。<br>这个<code>Configurer</code>其实就是在”FilterChain”上添加了一个过滤器，即<code>CorsFilter</code></p><p>我们都知道<code>CorsFilter</code>的构造方法需要一个<code>CorsConfigurationSource</code>，在请求到来时，使用<code>CorsProcessor</code>根据提供的<code>CorsConfiguration</code>去对请求进行处理（在<code>CorsFilter</code>中默认是<code>DefaultCorsProcessor</code>）而<code>CorsConfiguration</code>是通过<code>CorsConfigurationSource#getCorsConfiguration</code>方法获得的，所以说怎么获得<code>CorsConfigurationSource</code>至关重要。</p><p>还记得上面在配置<code>CorsConfigurationSource</code>时，我们直接注册Bean而不是通过<code>configurationSource()</code>方法指定吗？这种方法为什么是可行的呢？来看一下<code>CorsConfigurer</code>是如何获得<code>CorsConfigurationSource</code>并构造<code>CorsFilter</code>的：</p><figure class="highlight java"><figcaption><span>CorsConfigurer#getCorsFilter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CorsFilter <span class="title">getCorsFilter</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果指定了CorsConfigurationSource，那么用指定的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.configurationSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(<span class="keyword">this</span>.configurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> containsCorsFilter = context.containsBeanDefinition(CORS_FILTER_BEAN_NAME);</span><br><span class="line">    <span class="comment">//如果容器中已经有名字是’corsFilter‘的bean，则用已经有的</span></span><br><span class="line">    <span class="keyword">if</span> (containsCorsFilter) &#123; </span><br><span class="line">        <span class="keyword">return</span> context.getBean(CORS_FILTER_BEAN_NAME, CorsFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> containsCorsSource = context.containsBean(CORS_CONFIGURATION_SOURCE_BEAN_NAME);</span><br><span class="line">    <span class="comment">//如果既没有指定，容器中也不存在名字是’corsFilter‘的CorsFilter</span></span><br><span class="line">    <span class="comment">//那么看一下容器中有没有名字是’corsConfigurationSource‘的CorsConfigurationSource</span></span><br><span class="line">    <span class="comment">//如果有，取出来作为CorsConfigurationSource</span></span><br><span class="line">    <span class="keyword">if</span> (containsCorsSource) &#123;</span><br><span class="line">        CorsConfigurationSource configurationSource = context.getBean(CORS_CONFIGURATION_SOURCE_BEAN_NAME, CorsConfigurationSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(configurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果也没有corsConfigurationSource，看看类路径下存不存在HandlerMappingIntrospector这个类</span></span><br><span class="line">    <span class="keyword">boolean</span> mvcPresent = ClassUtils.isPresent(HANDLER_MAPPING_INTROSPECTOR,context.getClassLoader());</span><br><span class="line">    <span class="keyword">if</span> (mvcPresent) &#123; <span class="comment">//如果存在</span></span><br><span class="line">        <span class="keyword">return</span> MvcCorsFilter.getMvcCorsFilter(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcCorsFilter</span> </span>&#123; <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME = <span class="string">"mvcHandlerMappingIntrospector"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> CorsFilter <span class="title">getMvcCorsFilter</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!context.containsBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME, <span class="string">"A Bean named "</span> + </span><br><span class="line">            HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME +<span class="string">" of type "</span> + HandlerMappingIntrospector<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span></span><br><span class="line">            + " is required to use MvcRequestMatcher. Please ensure Spring Security &amp; Spring MVC are configured in a shared ApplicationContext.");</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从容器中取出HandlerMappingIntrospector作为CorsConfigurationSource</span></span><br><span class="line">        HandlerMappingIntrospector mappingIntrospector = context.getBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME, HandlerMappingIntrospector<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(mappingIntrospector);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取<code>CorsConfigurationSource</code>并构造<code>CorsFilter</code>的步骤注释里写的很清楚了，正常来说我们配置跨域配置源不管是直接指定也好，还是注册成Bean也好（注意Bean名字的要求），都是可以被获取到的。一般情况下，我们也的确是这样做的（直接提供一个<code>CorsConfigurationSource</code>）。但为什么最后有<code>MvcCorsFilter.getMvcCorsFilter(context)</code>这样一个调用？通过这个方法里抛出的异常信息不难猜测到是SpringSecurity为了兼容SpringMVC中配置跨域的方式。</p><p>还记得不使用SpringSecurity时如何在SpringMVC中配置支持跨域吗？</p><p><strong>两种方式：</strong></p><ul><li>将<code>@CrossOrigin</code>注解标注在支持跨域的接口上</li><li>重写<code>WebMvcConfigurer#addCorsMappings</code>方法进行全局配置</li></ul><p>看到这里你可能会猜测：是不是<code>HandlerMappingIntrospector</code>实现了<code>CorsConfigurationSource</code>，并且是根据上面两种方式的配置来返回跨域配置的呢？</p><p>事实上，的确是这样的。为了便于理解后面给出的代码，先来看看<code>CorsFilter</code>类和<code>CorsConfigurationSource</code>接口：</p><h4 id="CorsConfigurationSource"><a href="#CorsConfigurationSource" class="headerlink" title="CorsConfigurationSource"></a>CorsConfigurationSource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CorsConfigurationSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">CorsConfiguration <span class="title">getCorsConfiguration</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跨域配置源，实现类要实现<code>getCorsConfiguration</code>方法返回一个<code>CorsConfiguration</code>跨域配置，其中包含允许那些域、请求方法、请求头，是否允许携带凭证，缓存时间是多久，允许携带的头属性等信息。</p><p><code>CorsConfigurationSource</code>有五个实现类：</p><ul><li>CorsInterceptor</li><li>HandlerMappingIntrospector</li><li>PreFlightHandler</li><li>ResourceHttpRequestHandler</li><li>UrlBasedCorsConfigurationSource</li></ul><h4 id="CorsFilter"><a href="#CorsFilter" class="headerlink" title="CorsFilter"></a>CorsFilter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CorsConfigurationSource configSource;</span><br><span class="line">    <span class="keyword">private</span> CorsProcessor processor = <span class="keyword">new</span> DefaultCorsProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CorsFilter</span><span class="params">(CorsConfigurationSource configSource)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(configSource, <span class="string">"CorsConfigurationSource must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.configSource = configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorsProcessor</span><span class="params">(CorsProcessor processor)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(processor, <span class="string">"CorsProcessor must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.processor = processor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取CorsConfiguration</span></span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">this</span>.configSource.getCorsConfiguration(request);</span><br><span class="line">        <span class="comment">// 根据CorsConfiguration处理请求</span></span><br><span class="line">        <span class="keyword">boolean</span> isValid = <span class="keyword">this</span>.processor.processRequest(corsConfiguration, request, response);</span><br><span class="line">        <span class="keyword">if</span> (!isValid || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultCorsProcessor#processRequest</code>中根据请求是否跨域，是否是预检请求以及<code>CorsConfiguration</code>等信息来对请求进行处理和在响应头中写入一些信息。具体的源码就不分析了，还是比较好理解的。前提是需要对CORS有一定的了解，可以看下<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS）</a>这篇文章。</p><h3 id="HandlerMappingIntrospector"><a href="#HandlerMappingIntrospector" class="headerlink" title="HandlerMappingIntrospector"></a>HandlerMappingIntrospector</h3><p><code>HandlerMappingIntrospector</code>比较特别，不要认为这是个拦截器，”Introspector”翻译成中文是<em>内省者</em>的意思。</p><p>这个类在初始化后会调用<code>afterPropertiesSet</code>方法，将容器中所有的<code>HandlerMapping</code>添加到该类的<code>handlerMappings</code>这个<code>List</code>中。</p><p>来看一下官方对于这个类的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Helper class to get information from the HandlerMapping that would serve a specific request.</span><br><span class="line">Provides the following methods:</span><br><span class="line">    - getMatchableHandlerMapping(javax.servlet.http.HttpServletRequest) — obtain a HandlerMapping to check request-matching criteria against.</span><br><span class="line">    - getCorsConfiguration(javax.servlet.http.HttpServletRequest) — obtain the CORS configuration for the request.</span><br></pre></td></tr></table></figure><blockquote><p>这个类是一个帮助类，用于从<code>HandlerMapping</code>中获取请求的特定信息，提供了两个方法。第一个方法用于获取一个<code>MatchableHandlerMapping</code>来检查请求匹配条件，第二个方法用于获取适用于这个请求的<code>CorsConfiguration</code>跨域配置。</p></blockquote><p>我们重点关注第二个方法：</p><figure class="highlight java"><figcaption><span>HandlerMappingIntrospector#getCorsConfiguration</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CorsConfiguration <span class="title">getCorsConfiguration</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(<span class="keyword">this</span>.handlerMappings, <span class="string">"Handler mappings not initialized"</span>);</span><br><span class="line">    HttpServletRequest wrapper = <span class="keyword">new</span> RequestAttributeChangeIgnoringWrapper(request);</span><br><span class="line">    <span class="keyword">for</span> (HandlerMapping handlerMapping : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">        HandlerExecutionChain handler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler = handlerMapping.getHandler(wrapper); <span class="comment">// 获取处理执行链</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler.getInterceptors() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历拦截器，如果拦截器同时实现了CorsConfigurationSource则用这个拦截器作为跨域配置源</span></span><br><span class="line">            <span class="keyword">for</span> (HandlerInterceptor interceptor : handler.getInterceptors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> CorsConfigurationSource) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ((CorsConfigurationSource) interceptor).getCorsConfiguration(wrapper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从执行链获取处理器，如果处理器本身也实现了CorsConfigurationSource，则用处理器作为跨域配置源</span></span><br><span class="line">        <span class="keyword">if</span> (handler.getHandler() <span class="keyword">instanceof</span> CorsConfigurationSource) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((CorsConfigurationSource) handler.getHandler()).getCorsConfiguration(wrapper);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>CorsConfigurationSource</code>实现类根据请求从<code>HandlerMapping</code>中获取获取<code>HandlerExecutionChain</code>执行链，再依次从执行链的拦截器和处理器中获取<code>CorsConfigurationSource</code>，如果获取到了再调用其<code>HandlerMappingIntrospector#getCorsConfiguration</code>方法返回跨域配置。具体来说就是那两个if判断。</p><p>所以这么说来的话，<code>HandlerMappingIntrospector</code>虽然实现了<code>CorsConfigurationSource</code>但其本质有点像一个委托类？它检查请求对应的执行链上的拦截器和处理器有没有实现<code>CorsConfigurationSource</code>，如果有，再委托给这个<code>CorsConfigurationSource</code>来获取<code>CorsConfiguration</code>。所以说如果我们在一个<code>Controller</code>的接口上标注了<code>@CrossOrigin</code>注解，那么对应的，在拦截器中获取不到<code>CorsConfiguration</code>，就会从这个Handler上获取到<code>CorsConfiguration</code>，也就是将<code>@CrossOrigin</code>注解中提供的信息封装成了<code>CorsConfiguration</code>。那为什么还会先检查执行链中的拦截器呢？</p><p>因为SpringMVC中还有第二种方法配置跨域支持，也就是上面提到的重写<code>WebMvcConfigurer#addCorsMappings</code>方法进行全局配置。那为什么重写这个方法添加跨域配置最后会注册成拦截器呢？（一个实现了<code>CorsConfigurationSource</code>的拦截器）</p><p>这就要说到SpringBoot在WebMvc的自动配置、<code>WebMvcConfigurer</code>和<code>HandlerMapping</code>了。</p><p>如果你有仔细看过SpringBoot在SpringMVC的自动配置方面的源码，你一定知道<code>WebMvcConfigurationSupport</code>这个最主要的配置类在注册<code>HandlerMapping</code>的时候会从一个<code>CorsRegisty</code>中获取跨域配置：（这里以<code>RequestMappingHandlerMapping</code>为例）</p><figure class="highlight java"><figcaption><span>WebMvcConfigurationSupport.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">requestMappingHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Qualifier(<span class="string">"mvcContentNegotiationManager"</span>)</span> ContentNegotiationManager contentNegotiationManager,</span></span><br><span class="line"><span class="function">        @<span class="title">Qualifier</span><span class="params">(<span class="string">"mvcConversionService"</span>)</span> FormattingConversionService conversionService,</span></span><br><span class="line"><span class="function">        @<span class="title">Qualifier</span><span class="params">(<span class="string">"mvcResourceUrlProvider"</span>)</span> ResourceUrlProvider resourceUrlProvider) </span>&#123;</span><br><span class="line">            </span><br><span class="line">    RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping();</span><br><span class="line">    mapping.setOrder(<span class="number">0</span>);</span><br><span class="line">    mapping.setInterceptors(getInterceptors(conversionService, resourceUrlProvider));</span><br><span class="line">    mapping.setContentNegotiationManager(contentNegotiationManager);</span><br><span class="line">    mapping.setCorsConfigurations(getCorsConfigurations()); <span class="comment">//设置跨域配置</span></span><br><span class="line">    <span class="comment">// ...省略一大段set</span></span><br><span class="line">    <span class="keyword">return</span> mapping;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, CorsConfiguration&gt; <span class="title">getCorsConfigurations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.corsConfigurations == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CorsRegistry registry = <span class="keyword">new</span> CorsRegistry();</span><br><span class="line">        addCorsMappings(registry);  <span class="comment">//向CorsRegistry中添加跨域映射</span></span><br><span class="line">        <span class="keyword">this</span>.corsConfigurations = registry.getCorsConfigurations(); <span class="comment">//获取跨域配置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.corsConfigurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addCorsMappings()</code>方法是个空方法，并且只有<code>DelegatingWebMvcConfiguration</code>类重写了这个方法。实际上<code>WebMvcConfigurationSupport</code>这个类中用<code>@Bean</code>这个可传递的注解标注了很多方法但该类上并没有标注<code>@Configuration</code>，那么为什么还会起到配置类的作用呢？其实真正的配置类是<code>DelegatingWebMvcConfiguration</code>。</p><h3 id="DelegatingWebMvcConfiguration"><a href="#DelegatingWebMvcConfiguration" class="headerlink" title="DelegatingWebMvcConfiguration"></a>DelegatingWebMvcConfiguration</h3><p>在<code>DelegatingWebMvcConfiguration</code>这个类上有个<code>@Configuration</code>注解，并且继承自<code>WebMvcConfigurationSupport</code>，实际上它就是个委托类。</p><p><em>可以说这个类才是真正的配置类，去看看<code>DelegatingWebMvcConfiguration</code>这个类，相信你一定会发现什么！！！</em></p><p><code>DelegatingWebMvcConfiguration</code>中有<code>WebMvcConfigurerComposite</code>这么一个对象，并且将容器中所有<code>WebMvcConfigurer</code>注入进来：</p><figure class="highlight java"><figcaption><span>DelegatingWebMvcConfiguration.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// WebMvcConfigurer复合类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebMvcConfigurerComposite configurers = <span class="keyword">new</span> WebMvcConfigurerComposite();</span><br><span class="line">    <span class="comment">// 将容器中所有WebMvcConfigurer添加到WebMvcConfigurerComposite</span></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你去看了一下这个类的源码，你就会发现<code>WebMvcConfigurer</code>中有的方法这个类都有，并且这个委托类仅仅是将请求委托给<code>configurers</code>，来看看重写的<code>addCorsMappings</code>方法：</p><figure class="highlight java"><figcaption><span>DelegatingWebMvcConfiguration#addCorsMappings</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configurers.addCorsMappings(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>WebMvcConfigurerComposite#addCorsMappings</code>，显而易见<code>WebMvcConfigurerComposite</code>是个复合的<code>WebMvcConfigurer</code>，他也实现了<code>WebMvcConfigurer</code>并且内部维护了一个<code>List&lt;WebMvcConfigurer&gt; delegates</code>列表，实现的所有方法会依次调用列表中<code>WebMvcConfigurer</code>对应的方法。（并且你还能发现<code>WebMvcConfigurer</code>中的方法都是作为回调方法并且大部分是返回void的）</p><blockquote><p>说到这里，不得不说一个题外话。如果看Spring源码比较多的话，就会发现Spring中类的命名都有规律可循并且某些后缀都是有特定意义的，比如<code>xxxComposite</code>、<code>xxxConfigurer</code>、<code>Delegatingxxx</code>、<code>xxxDelegator</code>等等，这样我们看到这个类名就立马能猜到它的作用。</p></blockquote><p>我们平时对WebMvc进行一些配置都是实现<code>WebMvcConfigurer</code>类，重写其中的方法。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"*"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到这，也就是相当于<code>WebMvcConfigurationSupport#getCorsConfigurations</code>方法会回调容器中所有<code>WebMvcConfigurer</code>实现类的<code>addCorsMappings()</code>方法，向<code>CorsRegistry</code>中添加跨域映射，然后再取出<code>CorsConfiguration</code>返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, CorsConfiguration&gt; <span class="title">getCorsConfigurations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.corsConfigurations == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CorsRegistry registry = <span class="keyword">new</span> CorsRegistry();</span><br><span class="line">        addCorsMappings(registry); <span class="comment">//向CorsRegistry中添加跨域映射</span></span><br><span class="line">        <span class="keyword">this</span>.corsConfigurations = registry.getCorsConfigurations(); <span class="comment">//获取跨域配置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.corsConfigurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后反应到<code>AbstractHandlerMapping</code>中的就是使用<code>CorsConfiguration</code>注册一个<code>CorsInterceptor</code>拦截器，这个拦截器是<code>AbstractHandlerMapping</code>中的一个内部类，继承自<code>HandlerInterceptorAdapter</code>，并且实现了<code>CorsConfigurationSource</code>。</p><blockquote><p>看到这里，如果没有了解过<code>HandlerMapping</code>，可能会一头雾水，可以看看我的这篇文章<a href="/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/" title="源码角度分析Spring容器启动阶段注册Controller处理器的流程">源码角度分析Spring容器启动阶段注册Controller处理器的流程</a>，虽然不是讲<code>HandlerMapping</code>，但是相信在看完后，会对<code>HandlerMapping</code>有一个理解。</p></blockquote><h3 id="CorsInterceptor"><a href="#CorsInterceptor" class="headerlink" title="CorsInterceptor"></a>CorsInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> <span class="keyword">implements</span> <span class="title">CorsConfigurationSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CorsConfiguration config;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CorsInterceptor</span><span class="params">(@Nullable CorsConfiguration config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> corsProcessor.processRequest(<span class="keyword">this</span>.config, request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsConfiguration <span class="title">getCorsConfiguration</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类只重写了拦截器的<code>preHandle</code>方法，其他方法都是空方法。而且你能发现这个<code>preHandle</code>方法中的内容和<code>CorsFilter#doFilterInternal</code>方法基本是一模一样的，都是根据<code>CorsConfiguration</code>使用跨域处理器处理请求。</p><p>看到这里，现在应该知道关于<code>HandlerMappingIntrospector</code>的猜测是没错的，并且知道了<code>HandlerMappingIntrospector</code>是如何与SpringMVC两种支持跨域的配置方式联系起来的，这里再次总结一下：</p><ol><li>首先获取请求对应的执行链上的拦截器，判断拦截器有没有实现<code>CorsConfigurationSource</code>（<code>CorsInterceptor</code>类），如果有则调用<code>getCorsConfiguration</code>获取<code>CorsConfiguration</code>后返回</li><li>如果拦截器上获取失败，则判断处理器有没有实现<code>CorsConfigurationSource</code>（<code>PreFlightHandler</code>类），如果有则调用<code>getCorsConfiguration</code>获取<code>CorsConfiguration</code>后返回</li></ol><p>从而实现了兼容SpringMVC中两种配置跨域的方式。</p><p>这其中最关键的几点就在于<code>CorsConfigurer</code>获取<code>CorsConfigurationSource</code>并且构造<code>CorsFilter</code>的步骤、<code>HandlerMappingIntrospector</code>获取<code>CorsConfiguration</code>的步骤，还有Spring回调<code>WebMvcConfigurer</code>对<code>HandlerMapping</code>进行设置跨域配置等信息的步骤</p><p>其中还涉及到了SpringMVC中<code>HandlerMapping</code>、<code>HandlerExecutionChain</code>、<code>Handler</code>、<code>Interceptor</code>等相关知识。</p><p><strong>根据这次的分析，能得到几个结论：</strong></p><ul><li>SpringMVC支持跨域两种方式一个是基于处理器实现，另一个是基于拦截器实现。</li><li>SpringSecurity跨域是基于过滤器，并且兼容了SpringMVC的两种配置（使用<code>HandlerMappingIntrospector</code>“桥接”）。</li><li>SpringSecurity中的<code>CorsConfigurer</code>使用<code>HandlerMappingIntrospector</code>来兼容SpringMVC跨域两种方式。</li><li><code>HandlerMappingIntrospector</code>获取<code>CorsConfiguration</code>时的优先级是先拦截器，再处理器。</li><li>SpringBoot注册<code>HandlerMapping</code>或者说通过<code>WebMvcAutoConfiguration</code>自动配置来对WebMvc必要的组件进行装配和注入。</li><li><code>WebMvcConfigurer</code>是<code>DelegatingWebMvcConfiguration</code>类驱动<code>WebMvcConfigurerComposite</code>来进行回调的。</li></ul><p>并且经过这次的源码阅读，也是足足感受到Spring设计上的优雅。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>文章写的有点乱，并且有点跳跃。仅仅是跟着文章来看可能不大能看懂，最好在电脑上根据源码来阅读。这篇文章也仅仅是作为我个人在一次踩坑后好奇心大法，阅读源码后的一段总结以及感悟吧，自己能看懂并且以后还能看懂也就满意了。如果这篇文章有幸被你刷到并且你能够看懂我想表达的那我自然是更高兴。其实这个博客存在的理由也仅仅是为了记录自己学习过程中的感悟和总结，便于自己以后回顾，<del>毕竟我比较健忘</del>。所以需要记录下有必要的，并且在个人看来，这篇文章干货还是足足的，所以说更加有必要记录。其实在写文章之初我也不想写这么一篇文章，因为实在是太难写明白了，并且由于涉及到的东西比较分散很难进行组织，<del>也可能我表达能力差的原因吧</del>，但最终还是花了一下午加一晚上，在不断修改下产出了这么一篇很长很长很长的文章，可能是写过的字数最多的文章了吧😥。文章中可能有错别字也可能有错误的内容，如果你发现文章有什么错误的地方或者没表述清楚的内容，欢迎在评论中交流。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在SpringSecurity中配置跨域，我相信所有用过SpringSecurity的人应该都知道，因为实在是太简单了。那我为什么还要写这篇文章呢？写这篇文章的目的当然不是去解释如何配置跨域，而是通过分析Spring对跨域支持的源码来感受设计中的优雅。&lt;/p&gt;&lt;p&gt;先声明一下开发环境：&lt;code&gt;SpringBoot：2.2.2&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://lolico.me/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://lolico.me/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://lolico.me/tags/Web/"/>
    
      <category term="Security" scheme="https://lolico.me/tags/Security/"/>
    
      <category term="CORS" scheme="https://lolico.me/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>VueJS学习笔记：总结</title>
    <link href="https://lolico.me/2020/04/24/vue/"/>
    <id>https://lolico.me/2020/04/24/vue/</id>
    <published>2020-04-24T14:47:31.000Z</published>
    <updated>2022-02-17T12:19:03.233Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>原本是打算写一个<em>VueJS学习笔记</em>专栏，用于记录vue学习过程中的一些感想，但后来想想，如此做实在是太麻烦，并且每篇文章的篇幅也会比较短，所以现在考虑直接在这一篇博文中进行总结。将学习过程中的感谢或者踩得一些坑直接记录在此一篇文章中，尽量做到每个点都短小精悍。该篇博文并非最终稿，内容会随着文章的更新不断丰富。</p><p><strong>官方中文文档</strong>：</p><ul><li>Guide：<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></li><li>API：<a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/</a></li><li>Style Guide：<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/style-guide/</a></li><li>Examples：<a href="https://cn.vuejs.org/v2/examples/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/examples/</a></li></ul><blockquote><p>下面大部分内容都可以从官方文档中找到。这篇总结，仅将我个人认为有必要记录的进行汇总，以方便后续查找和回顾。</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ol><li>在选项属性或者回调方法使用箭头函数会导致在方法内使用<code>this</code>获取不到vue实例</li></ol><figure class="highlight javascript"><figcaption><span>错误示范</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">created: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">vm.$watch(<span class="string">'a'</span>, newValue =&gt; <span class="keyword">this</span>.myMethod())</span><br></pre></td></tr></table></figure><ol start="2"><li>事件总线机制下，监听总线事件的回调方法要使用箭头函数，否则this指代总线实例。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted()&#123; <span class="comment">// 挂载后执行</span></span><br><span class="line">  EventBus.$on(<span class="string">'event-name'</span>,data =&gt; &#123; <span class="comment">// 这里要用箭头函数，否则this指代EventBus</span></span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>v-bind</code>、<code>v-on</code>、<code>v-slot</code>指令使用<a href="https://cn.vuejs.org/v2/guide/syntax.html#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">动态指令参数</a>（2.6.0+）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">attr</span>]=<span class="string">"value"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">"value"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #[<span class="attr">solt</span>]&gt;</span>...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>attr</code>、<code>event</code>和<code>solt</code>会作为一个javascript表达式进行求值</p><ol start="4"><li><p>在DOM中使用模板时，避免使用大写字符来命名键名，因为浏览器会把attribute名全部强制转换为小写。</p></li><li><p>数据一般是从父组件流向子组件的，prop的值会因父组件中数据的改变而改变。</p></li><li><p>不要修改prop的值，如果一定要这么做，请使用计算属性或者data。</p></li><li><p>计算属性默认只有getter，但是我们也可以提供一个setter。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">        <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>父组件中的data可以是一个对象也可以是一个方法，但是子组件的data属性必须是一个方法。</p></li><li><p>由于JavaScript的限制，<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">Vue不能检测数组和对象的变化</a>。也就是说对对象的属性或数组进行修改添加删除不会反应到视图中（但值的却改变了），可以使用<code>vm.$set</code><a href="https://cn.vuejs.org/v2/api/#vm-set" target="_blank" rel="noopener">实例方法</a>（全局方法的别名），或<code>Vue.set</code><a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">全局方法</a>。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    lisi:&#123;</span><br><span class="line">      age: <span class="number">16</span>    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.lisi.age = <span class="number">18</span>; <span class="comment">// 直接对对象属性进行修改是不会直接响应到视图中</span></span><br><span class="line">vm.$<span class="keyword">set</span>(this.lisi,'age',18); // 响应式</span><br></pre></td></tr></table></figure><ol start="10"><li><code>v-if</code>和<code>v-show</code>的<a href="https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show" target="_blank" rel="noopener">异同</a>：</li></ol><ul><li><code>v-if</code>指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</li><li><code>v-show</code>指令通过修改元素的display属性让其显示或者隐藏</li></ul><ol start="11"><li><p>使用<code>v-cloak</code><a href="https://cn.vuejs.org/v2/api/#v-cloak" target="_blank" rel="noopener">指令</a>解决页面加载时闪烁的问题</p></li><li><p><a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">事件修饰符</a>、<a href="https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">按键修饰符</a>以及<a href="https://cn.vuejs.org/v2/guide/events.html#%E7%B3%BB%E7%BB%9F%E4%BF%AE%E9%A5%B0%E9%94%AE" target="_blank" rel="noopener">系统修饰键</a></p></li><li><p>使用<code>ref</code><a href="https://cn.vuejs.org/v2/api/#ref" target="_blank" rel="noopener">属性</a>在父组件中<a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">调用子组件的方法</a>。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span> Click this button &#123;&#123;count&#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">children</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span> Click this button &#123;&#123;count&#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> btn = &#123;</span></span><br><span class="line"><span class="actionscript">        template: <span class="string">'#btn'</span>,</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                count: 0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            add() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.count++;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            add() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.count++;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.$refs.child.add(); <span class="comment">// 调用子组件方法</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line"><span class="actionscript">            <span class="string">'children'</span>: btn</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Vue.js" scheme="https://lolico.me/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>修改评论插件为gitalk</title>
    <link href="https://lolico.me/2020/04/24/Change-comment-plugin-to-gitalk/"/>
    <id>https://lolico.me/2020/04/24/Change-comment-plugin-to-gitalk/</id>
    <published>2020-04-24T08:45:20.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><p>正式将评论插件由<a href="https://valine.js.org" target="_blank" rel="noopener">valine</a>更改为<a href="//github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a>，提高了评论的门槛，但考虑到文章受众以及博客类型，还是可以接受的。之前的评论丢失，<del>后续也可能会考虑回到<a href="https://valine.js.org" target="_blank" rel="noopener">valine</a></del>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;正式将评论插件由&lt;a href=&quot;https://valine.js.org&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="不正常的文章" scheme="https://lolico.me/categories/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="？？？" scheme="https://lolico.me/tags/%EF%BC%9F%EF%BC%9F%EF%BC%9F/"/>
    
  </entry>
  
  <entry>
    <title>VueJS学习笔记：记一次this无法获取vue实例的坑</title>
    <link href="https://lolico.me/2020/04/22/Why-cannot-use-this-pointer-to-get-vue-instance/"/>
    <id>https://lolico.me/2020/04/22/Why-cannot-use-this-pointer-to-get-vue-instance/</id>
    <published>2020-04-22T14:16:44.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><blockquote><p>不要在选项属性或回调上使用箭头函数，比如<code>created: () =&gt; console.log(this.a)</code>或<code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。因为箭头函数并没有<code>this</code>，<code>this</code>会作为变量一直向上级词法作用域查找，直至找到为止，经常导致<code>Uncaught TypeError: Cannot read property of undefined</code>或<code>Uncaught TypeError: this.myMethod is not a function</code>之类的错误。</p></blockquote><a id="more"></a><p>错误示范：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primay"</span> <span class="attr">icon</span>=<span class="string">"el-icon-plus"</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// ...</span></span></span><br><span class="line">        data: &#123;</span><br><span class="line">            count: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            add: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.count++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确示范：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        methods: &#123;</span><br><span class="line">            add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.count++</span><br><span class="line">            &#125;,</span><br><span class="line">            minus() &#123;</span><br><span class="line">                <span class="keyword">this</span>.count--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;blockquote&gt;&lt;p&gt;不要在选项属性或回调上使用箭头函数，比如&lt;code&gt;created: () =&amp;gt; console.log(this.a)&lt;/code&gt;或&lt;code&gt;vm.$watch(&amp;#39;a&amp;#39;, newValue =&amp;gt; this.myMethod())&lt;/code&gt;。因为箭头函数并没有&lt;code&gt;this&lt;/code&gt;，&lt;code&gt;this&lt;/code&gt;会作为变量一直向上级词法作用域查找，直至找到为止，经常导致&lt;code&gt;Uncaught TypeError: Cannot read property of undefined&lt;/code&gt;或&lt;code&gt;Uncaught TypeError: this.myMethod is not a function&lt;/code&gt;之类的错误。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Vue.js" scheme="https://lolico.me/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Git连接多个GitHub账号</title>
    <link href="https://lolico.me/2020/04/15/Git%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AAGitHub%E8%B4%A6%E5%8F%B7/"/>
    <id>https://lolico.me/2020/04/15/Git%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AAGitHub%E8%B4%A6%E5%8F%B7/</id>
    <published>2020-04-15T11:11:50.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用ssh连接GitHub，需要在GitHub账号上传唯一的公钥。当我们需要连接两个或多个GitHub账号，上传同一个公钥是不允许的，那么该如何设置才能在一台电脑上连接多个GitHub账号呢？</p><a id="more"></a><h2 id="创建密钥并上传到GitHub"><a href="#创建密钥并上传到GitHub" class="headerlink" title="创建密钥并上传到GitHub"></a>创建密钥并上传到GitHub</h2><p>假设我们已经有一对默认的密钥<code>id_rsa</code>、<code>id_rsa.pub</code>关联了a账号，现在我们来为b账号创建一个密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_b -C <span class="string">"youmail@example.com"</span></span><br></pre></td></tr></table></figure><p>注意文件名不要与其他的密钥重复，否则会覆盖之前的密钥。<br>windows下使用绝对路径：<code>C:\Users\xxx\.ssh\id_rsa_b</code></p><p>接下来我们就可以在用户目录下的<code>.ssh</code>文件夹中找到<code>id_rsa_b</code>和<code>id_rsa_b.pub</code>两个文件，将<code>id_rsa_b.pub</code>文件中的内容保存到b账号的ssh keys中。</p><h2 id="配置身份验证使用的密钥"><a href="#配置身份验证使用的密钥" class="headerlink" title="配置身份验证使用的密钥"></a>配置身份验证使用的密钥</h2><p>接下来我们要做的就是对不同账号配置使用不同的密钥去连接github。在<code>.ssh</code>文件夹中创建一个<code>config</code>文件（无扩展名），填入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># default</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line"></span><br><span class="line"># b</span><br><span class="line">Host b.github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_b</span><br></pre></td></tr></table></figure><p>在这部分配置中我们使用不同的主机标识去映射同一个<code>HostName</code>即github.com，但是我们使用不同的密钥文件去进行身份验证。</p><p>配置中的<code>Host</code>在不和其他<code>Host</code>重复的情况下可以随意填写，但是建议使用一眼就能看懂的标识（并且这个标识在后面是需要用到的）</p><p>到这里，其实所有的工作都已经完成。在进行下一步操作前我们先测试ssh是否能连接到github：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@b.github.com</span><br></pre></td></tr></table></figure><p>不出意外，我们将看到验证成功的提示。如果提示 CreateProcessW failed error:2，先将config文件中的代理设置注释便可，实际上并不影响后续对仓库的推送。</p><h2 id="对b账号的仓库单独设置用户名和邮箱"><a href="#对b账号的仓库单独设置用户名和邮箱" class="headerlink" title="对b账号的仓库单独设置用户名和邮箱"></a>对b账号的仓库单独设置用户名和邮箱</h2><p>现在我们要做的就是对b账号下的仓库进行设置，因为在原本只有一个账号时，我们应该都用过下面这个命令来对git设置一个全局的用户名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"a"</span></span><br><span class="line">git config --global user.email <span class="string">"a@example.com"</span></span><br></pre></td></tr></table></figure><p>现在我们当然不能对b账号下的仓库也使用全局的用户名和邮箱。如果使用全局的邮箱将b的仓库push到github，那么在github提交记录中看到的提交者将会是a，所以说我们需要对b账号下的仓库单独配置用户名和邮箱，进入项目文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">"b"</span></span><br><span class="line">git config user.email <span class="string">"b@example.com"</span></span><br></pre></td></tr></table></figure><p>邮箱要使用b账号注册github时使用的邮箱，因为github提交记录中的提交者是根据这个邮箱来查找的，这也是不能使用全局邮箱后提交者是a的原因。</p><h2 id="修改远程仓库的地址"><a href="#修改远程仓库的地址" class="headerlink" title="修改远程仓库的地址"></a>修改远程仓库的地址</h2><p>接下来我们还要重新设置远程仓库的地址，因为克隆仓库或者创建github仓库添加远程仓库地址时使用的主机标识默认是<code>github.com</code>，然而在config文件中对这个<code>Host</code>是使用<code>~/.ssh/id_rsa</code>密钥去验证，所以当我们本地已有b账号下的仓库或者未来克隆b账号下的仓库时要修改默认的远程仓库地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@b.github.com:b/repo.git</span><br></pre></td></tr></table></figure><p>注意不要照抄，根据config文件中配置的<code>Host</code>，github账号以及仓库名去设置‘@’符号后面的东西。</p><p>所有的工作都已经完成，push测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>如果我们单纯的使用<code>git push</code>可能会报错，因为虽然添加了远程仓库，但是并没有设置本地分支具体跟踪哪个上游分支。使用<code>-u</code>或<code>--set-upstream-to</code>选项运行<code>git branch</code>来显式地设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/master master</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，我们就是使用了不同的主机标识去映射github.com，并且对不同的标识在连接github时使用相应的密钥去验证身份。我们设置多个标识，相应的，我们也要修改远程仓库使用的Host标识（因为克隆下来的仓库的远程地址Host标识默认使用github.com）。虽然上面我们是拿两个账号来举例子，但是对于多个账号，设置的方法还是一模一样的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;用ssh连接GitHub，需要在GitHub账号上传唯一的公钥。当我们需要连接两个或多个GitHub账号，上传同一个公钥是不允许的，那么该如何设置才能在一台电脑上连接多个GitHub账号呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="git" scheme="https://lolico.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>python3安装dlib库</title>
    <link href="https://lolico.me/2020/04/12/python3%E5%AE%89%E8%A3%85dlib%E5%BA%93/"/>
    <id>https://lolico.me/2020/04/12/python3%E5%AE%89%E8%A3%85dlib%E5%BA%93/</id>
    <published>2020-04-12T06:44:09.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><p>python3编译安装dlib库十分麻烦，这里提供已经编译好的whl文件，使用pip直接安装即可。</p><a id="more"></a><ul><li><p>python3.6<br>下载：<a href="https://lolico.griouges.cn/download/dlib/dlib-19.8.1-cp36-cp36m-win_amd64.whl" target="_blank" rel="noopener">dlib-19.8.1-cp36-cp36m-win_amd64.whl</a><br>md5：9a704406fbb4036f70b5f174fec9db1f<br>sha1：e2e49b82b8dee6a9483362713239558c42c38fea</p></li><li><p>python3.7<br>下载：<a href="https://lolico.griouges.cn/download/dlib/dlib-19.17.99-cp37-cp37m-win_amd64.whl" target="_blank" rel="noopener">dlib-19.17.99-cp37-cp37m-win_amd64.whl</a><br>md5：b8c35e6e0098a7ece3e1a6935bbf1ae8<br>sha1：886f510821c3033649edcf86ea80ec1157f0b1a7</p></li><li><p>python3.8<br>下载：<a href="https://lolico.griouges.cn/download/dlib/dlib-19.19.0-cp38-cp38-win_amd64.whl" target="_blank" rel="noopener">dlib-19.19.0-cp38-cp38-win_amd64.whl</a><br>md5：7e00b04c3cf468e102b338d6837f4d5d<br>sha1：129d0142f1232d60c6571dc07eacdcd392b92f7b</p></li></ul><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install dlib-xx.xx.xx-cpxx-cpxx-win_amd64.whl  <span class="comment">#安装相应的文件</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;python3编译安装dlib库十分麻烦，这里提供已经编译好的whl文件，使用pip直接安装即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Python" scheme="https://lolico.me/tags/Python/"/>
    
      <category term="pip" scheme="https://lolico.me/tags/pip/"/>
    
      <category term="dlib" scheme="https://lolico.me/tags/dlib/"/>
    
  </entry>
  
  <entry>
    <title>解锁网易云音乐</title>
    <link href="https://lolico.me/2020/03/23/unblock-netease-music/"/>
    <id>https://lolico.me/2020/03/23/unblock-netease-music/</id>
    <published>2020-03-23T10:26:55.000Z</published>
    <updated>2022-02-17T12:19:03.233Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过配置下文中的代理，实现解锁网易云无版权音乐以及试听音乐，文中使用到的项目：<a href="https://github.com/nondanee/UnblockNeteaseMusic" target="_blank" rel="noopener">UnblockNeteaseMusic</a>。</p><blockquote><p>注意：互联网并非法外之地，此代理完全免费并仅用作学习与交流，使用过程中出现任何问题本人概不负责。如发现任何收费倒卖等行为请及时举报并反馈。</p></blockquote><h2 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h2><p>使用前你需要知道：</p><p>服务端已做限制：<em>仅允许代理网易云相关域名和ip的请求，其他请求一律拒绝。</em>由于服务器带宽只有5Mbps，所以理论速度不会超过640kb/s。如果使用的人比较多，可能出现加载比较慢的现象。建议网易云音乐内<strong>开启边听边存</strong>，常听的歌<strong>下载到本地</strong>。最后，你也可以通过文末的打赏按钮对我进行打赏鼓励~（大雾</p><p>现提供两种方法，不想折腾的使用<code>方法一</code>（局限性较大），否则请选择<code>方法二</code>（推荐）。</p><h3 id="方法一：系统代理PAC"><a href="#方法一：系统代理PAC" class="headerlink" title="方法一：系统代理PAC"></a>方法一：系统代理PAC</h3><p>使用系统代理PAC解锁是最简单的方法，缺点是 Android 和 iOS 只能在连接WiFi的环境下使用。下面介绍不同平台系统代理PAC的设置方法，对号入座。</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>以 Windows 10 为例，进入「Windows 设置」&gt;「网络和 Internet」&gt;「代理」&gt;「自动设置代理」&gt;「使用设置脚本」，填写以下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.lolico.me:39000&#x2F;proxy.pac</span><br></pre></td></tr></table></figure><p>进入网易云音乐「设置」&gt;「工具」&gt;「Http代理」，选择「使用 IE 代理设置」。</p><h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><p>进入「系统偏好设置」&gt;「网络」&gt;「高级」&gt;「代理」，填写以下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.lolico.me:39000&#x2F;proxy.pac</span><br></pre></td></tr></table></figure><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>进入「设置」&gt;「WLAN」&gt;「修改网络」&gt;「高级选项」&gt;「代理」&gt;「代理自动配置」（不同机型设置的地方不一样，也可能在wifi右边的感叹号中），填写以下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.lolico.me:39000&#x2F;proxy.pac</span><br></pre></td></tr></table></figure><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><p>首先下载<a href="https://raw.githubusercontent.com/nondanee/UnblockNeteaseMusic/master/ca.crt" target="_blank" rel="noopener">CA证书</a>（打不开的请挂代理），前往“设置-通用-描述文件”，安装「UnblockNeteaseMusic Root CA」，然后在“设置-通用-关于本机-证书信任设置”处开启对「UnblockNeteaseMusic Root CA」的信任，最后给当前连接的wifi配置http代理，选择自动并填入以下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.lolico.me:39000&#x2F;proxy.pac</span><br></pre></td></tr></table></figure><h3 id="方法二：代理软件"><a href="#方法二：代理软件" class="headerlink" title="方法二：代理软件"></a>方法二：代理软件</h3><p>使用代理软件，任何网络环境都可用，下面放上不同平台主流代理软件的使用步骤，至于文中没有提到的客户端，能力者自行根据提供的现有配置修改。</p><h4 id="Clash-for-Windows"><a href="#Clash-for-Windows" class="headerlink" title="Clash for Windows"></a>Clash for Windows</h4><ol><li>👉<a href="https://lolico.griouges.cn/download/clash/Clash.for.Windows.Setup.exe" target="_blank" rel="noopener">安装软件</a></li><li>👉<a href="clash://install-config?url=https%3a%2f%2flolico.me%2fsubscribe%2fClash%2fconfig.yaml">导入配置文件</a></li><li>👉进入「General」，开启「System Proxy」</li><li>👉进入网易云音乐「设置」&gt;「工具」&gt;「Http代理」，选择「使用 IE 代理设置」。</li><li>😘Enjoy it！</li></ol><h4 id="Clash-for-MacOS"><a href="#Clash-for-MacOS" class="headerlink" title="Clash for MacOS"></a>Clash for MacOS</h4><ol><li>👉<a href="https://lolico.griouges.cn/download/clash/ClashX.dmg" target="_blank" rel="noopener">安装软件</a></li><li>👉<a href="clash://install-config?url=https%3a%2f%2flolico.me%2fsubscribe%2fClash%2fconfig.yaml">导入配置文件</a></li><li>😘Enjoy it！</li></ol><h4 id="Clash-for-Android"><a href="#Clash-for-Android" class="headerlink" title="Clash for Android"></a>Clash for Android</h4><ol><li>👉<a href="https://lolico.griouges.cn/download/clash/app-armeabi-v7a-release.apk" target="_blank" rel="noopener">安装软件</a></li><li>👉<a href="clash://install-config?url=https%3a%2f%2flolico.me%2fsubscribe%2fClash%2fconfig.yaml">导入配置文件</a></li><li>👉保存后应用此配置</li><li>👉回到主界面启动代理</li><li>😘Enjoy it！</li></ol><p><strong>注意：</strong></p><p><del>鉴于安卓端<code>导入配置文件</code>无法调起Clash进行自动导入，请手动导入配置：</del>（最新版已支持，上方直接下载）</p><ol><li>👉进入Clash应用，依次点击「配置」&gt;「新配置」&gt;「从URL导入」</li><li>👉填写名称：lolico.me，URL地址：<a href="https://lolico.me/subscribe/Clash/config.yaml">https://lolico.me/subscribe/Clash/config.yaml</a> ，自动更新：1440</li><li>👉保存后选中此配置</li><li>👉回到主界面启动代理</li><li>😘Enjoy it！</li></ol><blockquote><p>Clash配置中有多个节点，当节点不可用时，请切换至其他节点或尝试更新配置文件。</p></blockquote><h4 id="iOS-1"><a href="#iOS-1" class="headerlink" title="iOS"></a>iOS</h4><p>首先下载<a href="https://raw.githubusercontent.com/nondanee/UnblockNeteaseMusic/master/ca.crt" target="_blank" rel="noopener">CA证书</a>（打不开的请挂代理），前往“设置-通用-描述文件”，安装「UnblockNeteaseMusic Root CA」，然后在“设置-通用-关于本机-证书信任设置”处开启对「UnblockNeteaseMusic Root CA」的信任。</p><h5 id="Shadowrocket"><a href="#Shadowrocket" class="headerlink" title="Shadowrocket"></a>Shadowrocket</h5><ol><li>👉<a href="https://apps.apple.com/us/app/shadowrocket/id932747118" target="_blank" rel="noopener">安装软件</a></li><li>👉<a href="shadowrocket://add/sub://aHR0cHM6Ly9sb2xpY28ubWUvc3Vic2NyaWJlL1NoYWRvd3JvY2tldC9zZXJ2ZXIudHh0#%F0%9F%8E%B8%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90">导入节点</a></li><li>👉<a href="shadowrocket://config/add/https://lolico.me/subscribe/Shadowrocket/rules.conf">导入配置</a></li><li>😘Enjoy it！</li></ol><h5 id="QuantumultX"><a href="#QuantumultX" class="headerlink" title="QuantumultX"></a>QuantumultX</h5><ol><li>👉<a href="https://apps.apple.com/us/app-bundle/quantumult-x-upgrade/id1482985563" target="_blank" rel="noopener">安装软件</a></li><li>👉<a href="quantumult-x:///update-configuration?remote-resource=%7B%0A%20%20%20%20%22server_remote%22%3A%20%5B%0A%20%20%20%20%20%20%20%20%22https%3A%2F%2Flolico.me%2Fsubscribe%2FQuantumultX%2FNeteaseMusicServer.txt%2C%20tag%3DNetease%20Music%2C%20img-url%3Dhttps%3A%2F%2Fraw.githubusercontent.com%2FKoolson%2FQure%2Fmaster%2FIconSet%2FNetease_Music_Unlock.png%22%0A%20%20%20%20%5D%2C%0A%20%20%20%20%22filter_remote%22%3A%20%5B%0A%20%20%20%20%20%20%20%20%22https%3A%2F%2Flolico.me%2Fsubscribe%2FQuantumultX%2FNeteaseMusicFilter.txt%2C%20tag%3D%F0%9F%8E%B8%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2C%20force-policy%3D%F0%9F%8E%B8%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2C%20enabled%3Dtrue%22%0A%20%20%20%20%5D%0A%7D">导入配置</a></li><li>👉进入应用，长按<code>🎸网易云音乐</code>策略组并添加解锁节点</li><li>😘Enjoy it！</li></ol><p>这里另外再提供一个包含：策略组、常用分流、脚本订阅的精简全局配置文件（适用于QuantumultX v1.0.10及以上版本）：<a href="https://lolico.me/subscribe/QuantumultX/simple.conf">https://lolico.me/subscribe/QuantumultX/simple.conf</a></p><blockquote><p>注意：如果测试节点连接延迟显示<code>timeout/超时</code>是正常的，服务端开启严格模式后仅能通过网易云相关域名或ip的请求。</p></blockquote><blockquote><p>部分解锁节点来自telegram频道，如有侵权，请联系删除，谢谢！</p></blockquote><hr><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li><p>为什么开启代理后，听数字专辑中的音乐会提示购买？</p><p>直接搜数字专辑中的音乐在播放时可能出现这种现象，尝试从专辑中进入并播放。</p></li><li><p>为什么开启代理后，登录网易云音乐提示网络异常？</p><p>先关闭代理再进行登录，进入后再开启代理。</p></li><li><p>为什么播放音乐提示网络不给力或者歌曲不存在？</p><p>iOS端出现网络不给力时，请确保CA证书已信任；歌曲不存在，请尝试使用其他节点解锁，不同节点在搜索音源时使用的平台不同，部分歌曲找不到是正常的现象。</p></li><li><p>为什么播放的音乐是live版或者完全不同的一首音乐？</p><p>由于解锁服务是从其他平台搜索音源，并且选择策略不可能做到十全十美，在音乐重名并且火热程度不同的情况下，可能会出现这种现象，目前没有较好的解决方法。</p></li><li><p>为什么开启代理后某些网站或应用加载资源很慢甚至失败？</p><p>由于使用代理并且根据请求分流，所以说相比不开代理理论上的确会有延迟（基本忽略不计）。如果感觉有明显的网络延迟并且确定不是由于自己网络环境较差所致，请在<em>必要时</em>再开启代理，日常上网关闭即可。</p></li><li><p>这写的都是些啥玩意？</p><p>……</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;
    
    </summary>
    
    
      <category term="不正常的文章" scheme="https://lolico.me/categories/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="？？？" scheme="https://lolico.me/tags/%EF%BC%9F%EF%BC%9F%EF%BC%9F/"/>
    
  </entry>
  
  <entry>
    <title>论如何用屎筑一座山</title>
    <link href="https://lolico.me/2020/03/23/Fucking-shit/"/>
    <id>https://lolico.me/2020/03/23/Fucking-shit/</id>
    <published>2020-03-23T03:57:06.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><a id="more"></a><p><em>网课现场</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> String sexView;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] SEXViews = <span class="keyword">new</span> String[]&#123;<span class="string">"女"</span>, <span class="string">"男"</span>&#125;;  <span class="comment">// #2-2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long date;</span><br><span class="line">    <span class="keyword">private</span> String dateView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(Integer sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="comment">// switch (sex) &#123; #1</span></span><br><span class="line">        <span class="comment">//     ...</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">this</span>.sexView = SEXViews[sex]; <span class="comment">// #2-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Long date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">        <span class="keyword">this</span>.dateView = DateFormat.toShortString(date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你品，你细细的品。</p><hr><p><em>货币需要格式化展示吗？</em></p><blockquote><p>当然是不需要（误</p></blockquote><p>货币格式化某些场景下是要的。球球了，看下org.springframework.format包下的东西吧。我觉得<code>@NumberFormatter</code>，和<code>@CurrencyFormatter</code>用的少，所以也是情有可原。但用到<code>@DateFormatter</code>的时候就没去看看这个注解的包下还提供了什么注解或者接口吗？？？</p><p><em>……</em></p><br><br><br><br><br><blockquote><p>哎，无奈自己不想造屎山，但现实却是，总有一堆屎山交到自己手上。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;
    
    </summary>
    
    
      <category term="不正常的文章" scheme="https://lolico.me/categories/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="？？？" scheme="https://lolico.me/tags/%EF%BC%9F%EF%BC%9F%EF%BC%9F/"/>
    
  </entry>
  
  <entry>
    <title>嵌套列表推导式</title>
    <link href="https://lolico.me/2020/03/15/%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/"/>
    <id>https://lolico.me/2020/03/15/%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/</id>
    <published>2020-03-15T06:36:20.000Z</published>
    <updated>2022-02-17T12:19:03.233Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><p>列表解析中的第一个表达式可以是任何表达式，包括列表解析。</p><p>考虑下面由三个长度为 4 的列表组成的 3x4 矩阵：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [</span><br><span class="line"><span class="meta">... </span>    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"><span class="meta">... </span>]</span><br></pre></td></tr></table></figure><p>现在，如果你想交换行和列，可以用嵌套的列表推导式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>像前面看到的，嵌套的列表推导式是对 for 后面的内容进行求值，所以上例就等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>反过来说，如下也是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># the following 3 lines implement the nested listcomp</span></span><br><span class="line"><span class="meta">... </span>    transposed_row = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line"><span class="meta">... </span>        transposed_row.append(row[i])</span><br><span class="line"><span class="meta">... </span>    transposed.append(transposed_row)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>在实际中，使用内置函数组成复杂流程语句。对此种情况<code>zip()</code>函数将会做的更好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;列表解析中的第一个表达式可以是任何表达式，包括列表解析。&lt;/p&gt;&lt;p&gt;考虑下面由三个长度为 4 的列表组成的 
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Python" scheme="https://lolico.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2020年JetBrains Quest 第三弹</title>
    <link href="https://lolico.me/2020/03/14/2020-JetBrains-Quest-Three/"/>
    <id>https://lolico.me/2020/03/14/2020-JetBrains-Quest-Three/</id>
    <published>2020-03-14T08:52:33.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><p>2020年3月13，JetBrains Quest第三弹到来：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314165330.png" alt=""></div><div class="image-caption"></div></figure><a id="more"></a><p>给个提示，上面的那一串是经过了<em>Base64编码</em></p><p>解谜后这次的奖励是一张8折优惠券？？？</p><br><br><br><br><br><br><br><br><br><br><p>算了算了，告辞</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;2020年3月13，JetBrains Quest第三弹到来：&lt;/p&gt;&lt;figure class=&quot;image-bubble&quot;&gt;&lt;div class=&quot;img-lightbox&quot;&gt;&lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;&lt;img src=&quot;https://lolico.griouges.cn/images/20200314165330.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="不正常的文章" scheme="https://lolico.me/categories/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="JetBrains Quest" scheme="https://lolico.me/tags/JetBrains-Quest/"/>
    
  </entry>
  
  <entry>
    <title>2020年JetBrains Quest 第二弹</title>
    <link href="https://lolico.me/2020/03/11/2020-JetBrains-Quest-Two/"/>
    <id>https://lolico.me/2020/03/11/2020-JetBrains-Quest-Two/</id>
    <published>2020-03-11T07:33:33.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><p>2020年3月11，JetBrains Quest第二弹到来：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314153806.png" alt=""></div><div class="image-caption"></div></figure><blockquote><p>.spleh A+lrtC/dmC .thgis fo tuo si ti semitemos ,etihw si txet nehw sa drah kooL .tseretni wohs dluohs uoy ecalp a si ,dessecorp si xat hctuD erehw esac ehT .sedih tseuq fo txen eht erehw si ,deificeps era segaugnal cificeps-niamod tcudorp ehT</p></blockquote><p>看着这一串数字不难看出来是经过reverse过的，python解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'.spleh A+lrtC/dmC .thgis fo tuo si ti semitemos ,etihw si txet nehw sa drah kooL .tseretni wohs dluohs uoy ecalp a si ,dessecorp si xat hctuD erehw esac ehT .sedih tseuq fo txen eht erehw si ,deificeps era segaugnal cificeps-niamod tcudorp ehT'</span></span><br><span class="line">print(s[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>The product domain-specific languages are specified, is where the next of quest hides. The case where Dutch tax is processed, is a place you should show interest. Look hard as when text is white, sometimes it is out of sight. Cmd/Ctrl+A helps.</p></blockquote><p>来到<a href="https://www.jetbrains.com/mps/" target="_blank" rel="noopener">MPS产品页</a>，搜索<code>Dutch tax</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314155001.png" alt=""></div><div class="image-caption"></div></figure><p>点击<code>Read MPS case study</code>跳转到一个PDF文件：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314155326.png" alt=""></div><div class="image-caption"></div></figure><p>还记得这个提示吗：</p><blockquote><p>Look hard as when text is white, sometimes it is out of sight. Cmd/Ctrl+A helps.</p></blockquote><p><code>Ctrl+A</code>试一下：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314155427.png" alt=""></div><div class="image-caption"></div></figure><p>右边有4行文字隐藏了，复制出来康康：</p><blockquote><p>This is our 20th year as a company,<br>we have shared numbers in our JetBrains<br>Annual report, sharing the section with<br>18,650 numbers will progress your que</p></blockquote><p>这句话的提到了<code>JetBrains Annual report</code>，看看去<a href="https://www.jetbrains.com/company/annualreport/2019/" target="_blank" rel="noopener">https://www.jetbrains.com/company/annualreport/2019/</a><br>在这个页面兜兜转转，搜索18650，怎么都发现不了什么线索，参考这个<a href="https://v2ex.com/t/651961" target="_blank" rel="noopener">帖子评论区</a>，发现这些数字加起来其实就是18650<br>而线索就藏在分享的编辑栏里面：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314160727.png" alt=""></div><div class="image-caption"></div></figure><p>点击分享：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314160831.png" alt=""></div><div class="image-caption"></div></figure><blockquote><p>I have found the JetBrains Quest! Sometimes you just need to look closely at the Haskell language, Hello,World! in the hackathon lego brainstorms project <a href="https://blog.jetbrains.com/blog/2019/11/22/jetbrains-7th-annual-hackathon/#JetBrainsQuest" target="_blank" rel="noopener">https://blog.jetbrains.com/blog/2019/11/22/jetbrains-7th-annual-hackathon/#JetBrainsQuest</a></p></blockquote><p>给了个博客链接，点进去搜索<code>lego brainstorms</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314161059.png" alt=""></div><div class="image-caption"></div></figure><p>还是没有头绪，F12开发者模式查看这种图片：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314161734.png" alt=""></div><div class="image-caption"></div></figure><p>发现在alt属性中有这么一串文字：</p><blockquote><p>d1D j00 kN0w J378r41n2 12 4lW4Y2 H1R1N9? ch3CK 0u7 73h K4r33r2 P493 4nD 533 1f 7H3r3 12 4 J08 F0r J00 0R 4 KW357 cH4LL3n93 70 90 fUr7h3r @ l3457.</p></blockquote><p>这玩意有的单词看着想是某些字母用数字代替，有的又看不出来，在gist上看了下才知道这是嘤文的火星文🙄🙄🙄，其实在第一弹的邮件里也有一串差不多的彩蛋。<br>翻译过来就是：</p><blockquote><p>Did you know Jetbrains is always hiring? Check out the kareers(careers) page and see if there is a job for you or for kwest(quest) challenge to go further at least.</p></blockquote><p>去<a href="https://www.jetbrains.com/careers/jobs/" target="_blank" rel="noopener">职位发布页面</a>看看：</p><p>搜索<code>Quest</code>并点进去：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314162653.png" alt=""></div><div class="image-caption"></div></figure><p>看一下啥是<code>cheat at Konami games</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314162956.png" alt=""></div><div class="image-caption"></div></figure><p><code>上上下下左右左右BA</code>，原来还有个名字叫做<code>Konami Code</code>，相当于一个隐藏游戏的启动代码。<br>魂斗罗30条命！我来辽！！！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314163313.png" alt=""></div><div class="image-caption"></div></figure><p>↑↑↓↓←→←→BA</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200314163436.png" alt=""></div><div class="image-caption"></div></figure><p>wow，打掉所有块，又白嫖到3个月的奖励，哈哈哈哈哈哈</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;2020年3月11，JetBrains Quest第二弹到来：&lt;/p&gt;&lt;figure class=&quot;image
      
    
    </summary>
    
    
      <category term="不正常的文章" scheme="https://lolico.me/categories/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="JetBrains Quest" scheme="https://lolico.me/tags/JetBrains-Quest/"/>
    
  </entry>
  
  <entry>
    <title>2020年JetBrains Quest 第一弹</title>
    <link href="https://lolico.me/2020/03/10/2020-JetBrains-Quest-One/"/>
    <id>https://lolico.me/2020/03/10/2020-JetBrains-Quest-One/</id>
    <published>2020-03-10T12:53:12.000Z</published>
    <updated>2022-02-17T12:19:03.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><p>2020年3月9日，JetBrains官方推特发布了这么一条消息：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200313155924.png" alt=""></div><div class="image-caption"></div></figure><blockquote><p>48 61 76 65 20 79 6f 75 20 73 65 65 6e 20 74 68 65 20 73 6f 75 72 63 65 20 63 6f 64 65 20 6f 66 20 74 68 65 20 4a 65 74 42 72 61 69 6e 73 20 77 65 62 73 69 74 65 3f</p></blockquote><p>观察这些数字，不难猜测是字符对应的ascii码的十六进制数，转换后，得到这样的提示：</p><blockquote><p>Have you seen the source code of the JetBrains website?</p></blockquote><p>问我们是否看过JetBrains网站的源码<br>打开<a href="https://www.jetbrains.com" target="_blank" rel="noopener">JetBrains官网</a>查看源码，搜索<code>JetBrains Quest</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200313160807.png" alt=""></div><div class="image-caption"></div></figure><blockquote><p>Welcome to the JetBrains Quest.<br>​<br>What awaits ahead is a series of challenges. Each one will require a little initiative, a little thinking, and a whole lot of JetBrains to get to the end. Cheating is allowed and in some places encouraged. You have until the 15th of March at 12:00 CET to finish all the quests.<br>Getting to the end of each quest will earn you a reward.<br>Let the quest commence!<br>​<br>JetBrains has a lot of products, but there is one that looks like a joke on our Products page, you should start there… (hint: use Chrome Incognito mode)<br>It’s dangerous to go alone take this key: Good luck! == Jrrg#oxfn$</p></blockquote><p>大概说的就是在3月15日欧洲中部时间12:00前完成谜题就可以拿到奖励，并且给了我们一个密钥：<code>Good luck! == Jrrg#oxfn$</code></p><p><em>谜题</em>：JetBrains有很多产品，但是在我们的产品页面上有一个看起来像joke的产品，您应该从那里开始…（提示：使用谷歌无痕模式）</p><p>谷歌浏览器无痕模式访问<a href="https://www.jetbrains.com/products.html" target="_blank" rel="noopener">JetBrains产品页</a>（实际上我不开无痕模式进入也是可以的）<br>在产品里找到一个叫<code>JK</code>的产品，点击<code>Learn More</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200313162013.png" alt=""></div><div class="image-caption"></div></figure><blockquote><p>You have discovered our JetBrains Quest! If you don’t know what this is, you should start from Twitter, Facebook or LinkedIn.<br>​<br>To continue to the next challenge you need to go to the following link… But there is a problem, the last 3 digits are missing:<br>​<br><a href="https://jb.gg/###" target="_blank" rel="noopener">https://jb.gg/###</a><br>​<br>To get these digits you need to know how many prime numbers there are between 500 and 5000<br>​<br>Good Luck!</p></blockquote><p>500到5000里有多少个质数，简单，574个。补充到链接上也就是让我们去这个地方：<a href="https://jb.gg/574" target="_blank" rel="noopener">https://jb.gg/574</a></p><p>重定向来到了这里：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200313163046.png" alt=""></div><div class="image-caption"></div></figure><p>如果你对JetBrains网站很了解你就会知道这个Logo是youtrack，也就是JebBrains网站的问题区，将后面的问题编码输进去，<br>得到链接：<a href="https://youtrack.jetbrains.com/issue/MPS-31816" target="_blank" rel="noopener">https://youtrack.jetbrains.com/issue/MPS-31816</a></p><p>跳转到这个页面：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://lolico.griouges.cn/images/20200313162923.png" alt=""></div><div class="image-caption"></div></figure><blockquote><p>JetBrains Quest<br>​<br>“The key is to think back to the beginning.” – The JetBrains Quest team<br>​<br>Qlfh$#Li#|rx#duh#uhdglqj#wklv#|rx#pxvw#kdyh#zrunhg#rxw#krz#wr#ghfu|sw#lw1#Wklv#lv#rxu#lvvxh#wudfnhu#ghvljqhg#iru#djloh#whdpv1#Lw#lv#iuhh#iru#xs#wr#6#xvhuv#lq#Forxg#dqg#iru#43#xvhuv#lq#Vwdqgdorqh/#vr#li#|rx#zdqw#wr#jlyh#lw#d#jr#lq#|rxu#whdp#wkhq#zh#wrwdoo|#uhfrpphqg#lw1#|rx#kdyh#ilqlvkhg#wkh#iluvw#Txhvw/#qrz#lw“v#wlph#wr#uhghhp#|rxu#iluvw#sul}h1#Wkh#frgh#iru#wkh#iluvw#txhvw#lv#‟WkhGulyhWrGhyhors†1#Jr#wr#wkh#Txhvw#Sdjh#dqg#xvh#wkh#frgh#wr#fodlp#|rxu#sul}h1#kwwsv=22zzz1mhweudlqv1frp2surpr2txhvw2</p></blockquote><p>告诉我们需要回头想一下密钥，那不就是网站源码里的<code>Good luck! == Jrrg#oxfn$</code>嘛。那后面那一串东西和这个有什么关系呢？<br>我就不卖关子了，其实也就是凯撒加密，源码里告诉我们的<code>Good luck! == Jrrg#oxfn$</code>其实就相当于一个输入输出案例：</p><p>明文<code>Good luck!</code>经凯撒加密后得到<code>Jrrg#oxfn$</code></p><blockquote><p>凯撒加密：将明文字符以某个数字移位得到另一个字符，说人话也就是把字符的ascii码加或者减某个数得到另一个字符的ascii也就是密文</p></blockquote><p>所以说给出的这个输入输出我们可以知道这个数字是3。</p><p>所以说将给出的这个密文还原成明文只需要将每个字符的ascii码减三得到的字符串就是明文了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </span><br><span class="line">    s = <span class="string">"Qlfh$#Li#|rx#duh#uhdglqj#wklv#|rx#pxvw#kdyh#zrunhg#rxw#krz#wr#ghfu|sw#lw1#Wklv#lv#rxu#lvvxh#wudfnhu#ghvljqhg#iru#djloh#whdpv1#Lw#lv#iuhh#iru#xs#wr#6#xvhuv#lq#Forxg#dqg#iru#43#xvhuv#lq#Vwdqgdorqh/#vr#li#|rx#zdqw#wr#jlyh#lw#d#jr#lq#|rxu#whdp#wkhq#zh#wrwdoo|#uhfrpphqg#lw1#|rx#kdyh#ilqlvkhg#wkh#iluvw#Txhvw/#qrz#lw“v#wlph#wr#uhghhp#|rxu#iluvw#sul&#125;h1#Wkh#frgh#iru#wkh#iluvw#txhvw#lv#‟WkhGulyhWrGhyhors†1#Jr#wr#wkh#Txhvw#Sdjh#dqg#xvh#wkh#frgh#wr#fodlp#|rxu#sul&#125;h1#kwwsv=22zzz1mhweudlqv1frp2surpr2txhvw2"</span></span><br><span class="line">    step = ord(<span class="string">'J'</span>)-ord(<span class="string">'G'</span>)    <span class="comment">#Good luck! == Jrrg#oxfn$</span></span><br><span class="line">    list = list(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list)):</span><br><span class="line">        list[i] = chr(ord(list[i]) - step)</span><br><span class="line">    print(<span class="string">""</span>.join(list))</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Nice! If you are reading this you must have worked out how to decrypt it. This is our issue tracker designed for agile teams. It is free for up to 3 users in Cloud and for 10 users in Standalone, so if you want to give it a go in your team then we totally recommend it. you have finished the first Quest, now it’s time to redeem your first prize. The code for the first quest is “TheDriveToDevelop”. Go to the Quest Page and use the code to claim your prize. <a href="https://www.jetbrains.com/promo/quest/" target="_blank" rel="noopener">https://www.jetbrains.com/promo/quest/</a></p></blockquote><p>得到一个网址和兑换码。</p><p>接下来的兑奖环节应该就不用多说了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;2020年3月9日，JetBrains官方推特发布了这么一条消息：&lt;/p&gt;&lt;figure class=&quot;ima
      
    
    </summary>
    
    
      <category term="不正常的文章" scheme="https://lolico.me/categories/%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="JetBrains Quest" scheme="https://lolico.me/tags/JetBrains-Quest/"/>
    
  </entry>
  
  <entry>
    <title>获取泛型参数的类型</title>
    <link href="https://lolico.me/2020/03/10/%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B/"/>
    <id>https://lolico.me/2020/03/10/%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-10T09:18:17.000Z</published>
    <updated>2022-02-17T12:19:03.233Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><p>现在有这样一个场景：有一个按钮监听器类<code>ButtonListener</code>：</p><figure class="highlight java"><figcaption><span>ButtonListener.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> me.lolico.demo.button.event.ButtonEvent;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ButtonListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ButtonEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onButtonEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及一个监听按钮name是否改变即<code>ButtonNameHasChangedEvent</code>事件的实现类<code>ButtonNameListener</code>：</p><figure class="highlight java"><figcaption><span>ButtonNameListener.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> me.lolico.demo.button.Button;</span><br><span class="line"><span class="keyword">import</span> me.lolico.demo.button.ButtonListener;</span><br><span class="line"><span class="keyword">import</span> me.lolico.demo.button.event.ButtonNameHasChangedEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lolico li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ButtonNameListener</span> <span class="keyword">implements</span> <span class="title">ButtonListener</span>&lt;<span class="title">ButtonNameHasChangedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonEvent</span><span class="params">(ButtonNameHasChangedEvent event)</span> </span>&#123;</span><br><span class="line">        Button button = (Button) event.getSource();</span><br><span class="line">        System.out.println(button + <span class="string">"name has changed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用设置按钮<code>setName</code>方法时需要发布<code>ButtonNameHasChangedEvent</code>事件，我们需要怎么去通知监听这个事件的监听器呢？</p><blockquote><p>我们需要获取到所有的按钮监听器，然后遍历，获取泛型类型，如果类型匹配，那么则通知这个监听器</p></blockquote><p>所以现在问题变成了如何获取按钮监听器的泛型类型，如果我们百度一下，清一色的答案都是下面这种：</p><figure class="highlight java"><figcaption><span>获取某个类的泛型参数的类型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ParameterizedType) clazz.getGenericSuperclass()).getActualTypeArguments()</span><br></pre></td></tr></table></figure><p>对于这种场景，那么就是一个异常抛出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.reflect.ParameterizedType</span><br></pre></td></tr></table></figure><p>为什么呢，因为<code>Class#getGenericSuperclass()</code>方法返回的是超类的Type，所以说这种方法只能用于获取超类上面的泛型类型，而我们上面的案例明显是要获取接口上的的泛型类型，所以我们应该使用的是<code>Class#getGenericInterfaces()</code>方法。</p><p>获取一个类上的所有泛型类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Type&gt; <span class="title">resolveGenericType</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    Set&lt;Type&gt; genericSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Type superclass = clazz.getGenericSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (superclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        genericSet.addAll(Arrays.asList(((ParameterizedType) superclass).getActualTypeArguments()));</span><br><span class="line">    &#125;</span><br><span class="line">    Type[] interfaces = clazz.getGenericInterfaces();</span><br><span class="line">    <span class="keyword">for</span> (Type type : interfaces) &#123;</span><br><span class="line">        Type[] genericType = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class="line">        genericSet.addAll(Arrays.asList(genericType));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> genericSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：</em>获取的泛型类型不包括实现的接口继承的接口上的泛型类型，因为<code>Class#getGenericInterfaces()</code>方法不是递归获取所有接口类型，只获取当前类实现的接口的类型。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;现在有这样一个场景：有一个按钮监听器类&lt;code&gt;ButtonListener&lt;/code&gt;：&lt;/p&gt;&lt;fig
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://lolico.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>源码角度分析Spring容器启动阶段注册Controller处理器的流程</title>
    <link href="https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/</id>
    <published>2020-03-09T08:09:08.000Z</published>
    <updated>2022-02-17T12:19:03.233Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，在一个请求被前端控制器<code>DispatchServlet</code>捕获后会经历下面几个流程：</p><ol><li><code>DispatherServlet</code>根据请求URL解析获取请求URI，调用<code>HandlerMapping#getHandler</code>方法获取<code>HandlerExecutionChain</code></li><li>获取返回的<code>HandlerExecutionChain</code>处理器执行链（包括处理器对象和拦截器对象）</li><li>根据处理器执行链获取一个处理器适配器<code>HandlerAdapter</code>，如果成功获取，则开始执行拦截器）</li><li>处理器适配器根据请求的<code>Handler</code>（一般来说是<code>HandlerMethod</code>）适配并根据配置的<code>HttpMessageConveter</code>将请求消息解析为模型数据，填充 <code>Handler</code>入参，开始执行处理器逻辑。</li><li>处理器执行完毕，返回<code>ModelAndView</code>，处理器适配器接收到后返回给<code>DispatherServlet</code></li><li><code>DispatherServlet</code>根据模型和视图请求对应的视图解析器</li><li>视图解析器解析模型数据获取对应的视图，渲染视图后返回给<code>DispatherServlet</code></li><li><code>DispatherServlet</code>将渲染后的视图相应给用户或客户端</li></ol><p>那么Spring容器启动后是如何自动发现处理器（我在这称之为<strong>自动发现机制</strong>）并进行注册的呢？</p><blockquote><p>在web环境下Spring容器启动时会注册<code>HandlerMapping</code>，具体在SpringBoot中，<code>WebMvcAutoConfiguration</code>会通过<code>WebMvcConfigurationSupport#requestMappingHandlerMapping</code>方法向容器中注册一个<code>HandlerMapping</code>的实现<code>RequestMappingHandlerMapping</code></p></blockquote><h2 id="自动发现机制的实现"><a href="#自动发现机制的实现" class="headerlink" title="自动发现机制的实现"></a>自动发现机制的实现</h2><p>Spring容器启动时会注册<code>HandlerMapping</code>，在这里我们就以<code>RequestMappingHandlerMapping</code>实现类为例进行分析</p><h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><p><code>RequestMappingHandlerMapping#afterPropertiesSet</code>方法实际上调用了父类的<code>afterPropertiesSet</code>的方法：</p><figure class="highlight java"><figcaption><span>RequestMappingHandlerMapping#afterPropertiesSet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line"><span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在父类的这个方法中进行初始化处理器逻辑：</p><figure class="highlight java"><figcaption><span>AbstractHandlerMethodMapping#afterPropertiesSet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Detects handler methods at initialization.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #initHandlerMethods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">initHandlerMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>initHandlerMethods</code>方法中先从容器中获取所有的候选bean，调用<code>processCandidateBean</code>方法：</p><figure class="highlight java"><figcaption><span>AbstractHandlerMethodMapping#initHandlerMethods</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCandidateBeanNames()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #processCandidateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handlerMethodsInitialized</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">processCandidateBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>processCandidateBean</code>方法中根据bean的类型调用由子类实现的<code>isHandler</code>方法判断是否是处理器，然后调用<code>detectHandlerMethods</code>方法寻找该处理器中的处理方法并注册。</p><p>来看下<code>RequestMappingHandlerMapping#isHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller<span class="class">.<span class="keyword">class</span>) ||</span></span><br><span class="line"><span class="class"><span class="title">AnnotatedElementUtils</span>.<span class="title">hasAnnotation</span>(<span class="title">beanType</span>, <span class="title">RequestMapping</span>.<span class="title">class</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的<code>AnnotatedElementUtils#hasAnnotation</code>方法，最终会调用到<code>AnnotatedElementUtils#searchWithFindSemantics</code>方法，代码片段如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = (Class&lt;?&gt;) element;</span><br><span class="line">    <span class="keyword">if</span> (!Annotation<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)) </span>&#123;</span><br><span class="line">        <span class="comment">// Search on interfaces 在实现接口中查找</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; ifc : clazz.getInterfaces()) &#123;</span><br><span class="line">            T result = searchWithFindSemantics(ifc, annotationTypes, annotationName,</span><br><span class="line">                    containerType, processor, visited, metaDepth);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Search on superclass 在父类中查找</span></span><br><span class="line">        Class&lt;?&gt; superclass = clazz.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            T result = searchWithFindSemantics(superclass, annotationTypes, annotationName,</span><br><span class="line">                    containerType, processor, visited, metaDepth);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现这个地方查找是否有指定注解时，如果继承的类或实现的接口有相应的注解也是可以的，这个特性在某些情况下是很有用的，比如在自动配置类中可以利用这一特点，使用<code>@Bean</code>注解再配合<code>@Conditionalxxx</code>等注解实现按需注入Controller。我们只要定义一个<em>标记类/接口</em>，再在该类上注解<code>@Controller</code>或<code>@RequestMapping</code>，然后让需要按需注入的Controller继承这个<em>标记类/接口</em>即可。</p><blockquote><p>注意，在一般情况下使用<code>@Bean</code>或<code>@Component</code>注解是不能将一个Bean注册为Controller的</p></blockquote><h4 id="AbstractHandlerMethodMapping-detectHandlerMethods"><a href="#AbstractHandlerMethodMapping-detectHandlerMethods" class="headerlink" title="AbstractHandlerMethodMapping#detectHandlerMethods"></a>AbstractHandlerMethodMapping#detectHandlerMethods</h4><p>现在我们来看下这个自动发现机制中最关键的方法：</p><figure class="highlight java"><figcaption><span>AbstractHandlerMethodMapping#detectHandlerMethods</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 获取用户定义的类，防止在代理模式下不能获取到方法以及上面的注解</span></span><br><span class="line">Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">           <span class="comment">// 返回方法及其相关元数据的一个map，元数据是回调lambda获取的，可以看下MetadataLookup#inspect函数式接口</span></span><br><span class="line">Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">// 由子类实现的抽象方法</span></span><br><span class="line">                           <span class="comment">// 在RequestMappingHandlerMapping中是RequestMappingInfo</span></span><br><span class="line"><span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(formatMappings(userType, methods));</span><br><span class="line">&#125;</span><br><span class="line">methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">               <span class="comment">// 获取该方法的可调用方法</span></span><br><span class="line">Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">               <span class="comment">// 注册</span></span><br><span class="line">registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>RequestMappingHandlerMapping#getMappingForMethod</code>中先检查是否注解了<code>@RequestMapping</code>，如果有则获取注解中的请求的路径，请求的方式（GET,POST,…)等等信息，封装到<code>RequestMappingInfo</code>中返回，具体的代码就不放了，还是很好理解的。</p><p>再来看下最后这个<code>AbstractHandlerMethodMapping#registerHandlerMethod</code>方法</p><figure class="highlight java"><figcaption><span>AbstractHandlerMethodMapping#registerHandlerMethod</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好理解，调用<code>mappingRegistry#register</code>方法进行注册，那这个<code>mappingRegistry</code>是什么东西呢？</p><blockquote><p><code>MappingRegistry</code>实际上就是<code>AbstractHandlerMethodMapping</code>类中的一个内部类，看名字很好理解：映射注册表，这个类中维护了存放映射信息的map</p></blockquote><h3 id="MappingRegistry"><a href="#MappingRegistry" class="headerlink" title="MappingRegistry"></a>MappingRegistry</h3><p><code>MappingRegistry</code>是<code>AbstractHandlerMethodMapping</code>类中的一个内部类，在其中维护了五个用于存放映射信息的Map：</p><figure class="highlight java"><figcaption><span>MappingRegistry类字段</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正意义上的注册表，以RequestMappingInfo为key</span></span><br><span class="line"><span class="comment">// MappingRegistration中存放请求映射信息RequestMappingInfo、处理器方法HandlerMethod（即标注了@RequestMapping的处理方法）、映射路径url、处理器name</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// RequestMappingInfo和HandlerMethod的map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, HandlerMethod&gt; mappingLookup = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// url(请求路径)和RequestMappingInfo的map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, T&gt; urlLookup = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 处理器name和处理器方法的map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;HandlerMethod&gt;&gt; nameLookup = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 处理器方法和跨域配置的map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;HandlerMethod, CorsConfiguration&gt; corsLookup = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="MappingRegistry-register"><a href="#MappingRegistry-register" class="headerlink" title="MappingRegistry#register"></a>MappingRegistry#register</h4><figure class="highlight java"><figcaption><span>MappingRegistry#register</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Assert that the handler method is not a suspending one.</span></span><br><span class="line"><span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass()) &amp;&amp; KotlinDelegate.isSuspend(method)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported suspending handler method detected: "</span> + method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 创建处理器方法</span></span><br><span class="line">HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">validateMethodMapping(handlerMethod, mapping);</span><br><span class="line">              <span class="comment">// 将映射信息和处理器方法放到map中</span></span><br><span class="line"><span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"><span class="comment">// 获取映射的请求路径数组，在RequestMapping注解中可对一个方法指定多个映射路径</span></span><br><span class="line">List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line"><span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line">                  <span class="comment">// 放入map</span></span><br><span class="line"><span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">&#125;</span><br><span class="line">              <span class="comment">// 如果name存储策略不为空，将处理器name和处理器方法放到nameLookup map中</span></span><br><span class="line">String name = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">                  <span class="comment">// 将处理器name和处理器方法放到nameLookup map中</span></span><br><span class="line">addMappingName(name, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">              <span class="comment">// 跨域配置</span></span><br><span class="line">CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line"><span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">&#125;</span><br><span class="line">              <span class="comment">// 将映射信息和MappingRegistration放到注册表Map</span></span><br><span class="line"><span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法说白了，就是把处理器，处理器方法，请求映射信息等等信息放到Map中，看到这里可能会对<code>RequestMappingInfo</code>和 <code>MappingRegistration</code>这两个东西感到疑惑，其实很简单，前者是Spring容器启动时控制器自动发现机制根据方法上<code>@RequestMapping</code>注解中的信息封装的对象，<strong>决定了什么样的请求能命中那个处理器方法</strong>，这也是<code>MappingRegistry#registry</code>注册表中以<code>RequestMappingInfo</code>为key的原因，而<code>MappingRegistration</code>中封装了处理器<code>Handler</code>,处理器方法<code>HandlerMethod</code>信息。</p><br><p>所以现在能知道一个请求到来时是如何<strong>找到处理器方法</strong>并调用的了：</p><blockquote><p>根据请求的url到<code>MappingRegistry#urlLookup</code>字段中匹配，如果匹配上，则取出对应的<code>RequestMappingInfo</code>，再到<code>MappingRegistry#registry</code>字段中取出<code>MappingRegistration</code>，再取出<code>MappingRegistration</code>中的处理器<code>Handler</code>和方法<code>HandlerMethod</code>，反射调用完成请求。</p></blockquote><p>当然，这只是大概的流程。</p><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>Spring容器启动，注册处理器的流程分析完了。其实说白了，Spring容器注册控制器就是扫描容器中的bean然后检查是否是控制器Controller，然后将其中注解有<code>@RequestMapping</code>的方法注册为处理器方法。</p><p>其实<code>HandlerMapping</code>的实现类并不是只有<code>RequestMappingHandlerMapping</code>一个，但是是<code>AbstractHandlerMethodMapping</code>提供的<strong>主要的</strong>实现逻辑，而实现类只是提供了基础的判断：是否是处理器（<code>isHandler</code>)，获取请求映射信息<code>getMappingForMethod</code>等抽象方法，所以说如果在某些场景下需要实现自定义的<code>HandlerMapping</code>时我们可以通过继承<code>RequestMappingInfoHandlerMapping</code>然后重写<code>isHandler</code>和<code>getMappingForMethod</code>方法即可。（<code>RequestMappingHandlerMapping</code>继承自<code>RequestMappingInfoHandlerMapping</code>）</p><p>至于案例，以后有空了再补上</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 17 2022 12:19:14 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="正常的文章" scheme="https://lolico.me/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://lolico.me/tags/Spring/"/>
    
      <category term="Web" scheme="https://lolico.me/tags/Web/"/>
    
      <category term="Java" scheme="https://lolico.me/tags/Java/"/>
    
  </entry>
  
</feed>
