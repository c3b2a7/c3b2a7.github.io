<!-- build time:Fri May 13 2022 16:24:30 GMT+0000 (Coordinated Universal Time) --><!DOCTYPE html><html><head><meta charset="utf-8"><title>源码角度分析Spring容器启动阶段注册Controller处理器的流程 | 萌面喵喵侠</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#3F51B5"><meta name="keywords" content="Spring,Java,Web"><meta name="description" content="前言我们都知道，在一个请求被前端控制器DispatchServlet捕获后会经历下面几个流程：DispatherServlet根据请求URL解析获取请求URI，调用HandlerMapping#getHandler方法获取HandlerExecutionChain获取返回的HandlerExecutionChain处理器执行链（包括处理器对象和拦截器对象）根据处理器执行链获取一个处理器适配器Han"><meta property="og:type" content="article"><meta property="og:title" content="源码角度分析Spring容器启动阶段注册Controller处理器的流程"><meta property="og:url" content="https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/index.html"><meta property="og:site_name" content="萌面喵喵侠"><meta property="og:description" content="前言我们都知道，在一个请求被前端控制器DispatchServlet捕获后会经历下面几个流程：DispatherServlet根据请求URL解析获取请求URI，调用HandlerMapping#getHandler方法获取HandlerExecutionChain获取返回的HandlerExecutionChain处理器执行链（包括处理器对象和拦截器对象）根据处理器执行链获取一个处理器适配器Han"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-03-09T08:09:08.000Z"><meta property="article:modified_time" content="2022-05-13T16:24:11.655Z"><meta property="article:author" content="萌面喵喵侠"><meta property="article:tag" content="Spring"><meta property="article:tag" content="Java"><meta property="article:tag" content="Web"><meta name="twitter:card" content="summary"><link rel="alternate" type="application/atom+xml" title="萌面喵喵侠" href="/atom.xml"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css"><script>window.lazyScripts=[]</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading" class="active"></div><aside id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap" style="background-image:url(/img/brand.jpg)"><div class="brand"><a href="/" class="avatar waves-effect waves-circle waves-light"><img src="/img/avatar.jpg"></a><hgroup class="introduce"><h5 class="nickname">萌面喵喵侠</h5><a href="mailto:534619360@qq.com" title="534619360@qq.com" class="mail">534619360@qq.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> 归档</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> 标签</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="icon icon-lg icon-th-list"></i> 分类</a></li></ul></div></div></aside><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">源码角度分析Spring容器启动阶段注册Controller处理器的流程</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"><i class="icon icon-lg icon-share-alt"></i></a></div></header><header class="content-header post-header"><div class="container fade-scale"><h1 class="title">源码角度分析Spring容器启动阶段注册Controller处理器的流程</h1><h5 class="subtitle"><time datetime="2020-03-09T08:09:08.000Z" itemprop="datePublished" class="page-time">2020-03-09</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/">正常的文章</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap post-toc-shrink" id="post-toc"><h4>TOC</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#自动发现机制的实现"><span class="post-toc-number">2.</span> <span class="post-toc-text">自动发现机制的实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#RequestMappingHandlerMapping"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">RequestMappingHandlerMapping</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AbstractHandlerMethodMapping-detectHandlerMethods"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">AbstractHandlerMethodMapping#detectHandlerMethods</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MappingRegistry"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">MappingRegistry</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#MappingRegistry-register"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">MappingRegistry#register</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#后语"><span class="post-toc-number">3.</span> <span class="post-toc-text">后语</span></a></li></ol></nav></aside><article id="post-源码角度分析Spring容器启动阶段注册Controller处理器的流程" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">源码角度分析Spring容器启动阶段注册Controller处理器的流程</h1><div class="post-meta"><time class="post-time" title="2020-03-09 16:09:08" datetime="2020-03-09T08:09:08.000Z" itemprop="datePublished">2020-03-09</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%87%E7%AB%A0/">正常的文章</a></li></ul><span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none"><i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span></span></div><div class="post-content" id="post-content" itemprop="postContent"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，在一个请求被前端控制器<code>DispatchServlet</code>捕获后会经历下面几个流程：</p><ol><li><code>DispatherServlet</code>根据请求URL解析获取请求URI，调用<code>HandlerMapping#getHandler</code>方法获取<code>HandlerExecutionChain</code></li><li>获取返回的<code>HandlerExecutionChain</code>处理器执行链（包括处理器对象和拦截器对象）</li><li>根据处理器执行链获取一个处理器适配器<code>HandlerAdapter</code>，如果成功获取，则开始执行拦截器）</li><li>处理器适配器根据请求的<code>Handler</code>（一般来说是<code>HandlerMethod</code>）适配并根据配置的<code>HttpMessageConveter</code>将请求消息解析为模型数据，填充 <code>Handler</code>入参，开始执行处理器逻辑。</li><li>处理器执行完毕，返回<code>ModelAndView</code>，处理器适配器接收到后返回给<code>DispatherServlet</code></li><li><code>DispatherServlet</code>根据模型和视图请求对应的视图解析器</li><li>视图解析器解析模型数据获取对应的视图，渲染视图后返回给<code>DispatherServlet</code></li><li><code>DispatherServlet</code>将渲染后的视图相应给用户或客户端</li></ol><p>那么Spring容器启动后是如何自动发现处理器（我在这称之为<strong>自动发现机制</strong>）并进行注册的呢？</p><blockquote><p>在web环境下Spring容器启动时会注册<code>HandlerMapping</code>，具体在SpringBoot中，<code>WebMvcAutoConfiguration</code>会通过<code>WebMvcConfigurationSupport#requestMappingHandlerMapping</code>方法向容器中注册一个<code>HandlerMapping</code>的实现<code>RequestMappingHandlerMapping</code></p></blockquote><h2 id="自动发现机制的实现"><a href="#自动发现机制的实现" class="headerlink" title="自动发现机制的实现"></a>自动发现机制的实现</h2><p>Spring容器启动时会注册<code>HandlerMapping</code>，在这里我们就以<code>RequestMappingHandlerMapping</code>实现类为例进行分析</p><h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><p><code>RequestMappingHandlerMapping#afterPropertiesSet</code>方法实际上调用了父类的<code>afterPropertiesSet</code>的方法：</p><figure class="highlight java"><figcaption><span>RequestMappingHandlerMapping#afterPropertiesSet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">	<span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在父类的这个方法中进行初始化处理器逻辑：</p><figure class="highlight java"><figcaption><span>AbstractHandlerMethodMapping#afterPropertiesSet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Detects handler methods at initialization.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #initHandlerMethods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	initHandlerMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>initHandlerMethods</code>方法中先从容器中获取所有的候选bean，调用<code>processCandidateBean</code>方法：</p><figure class="highlight java"><figcaption><span>AbstractHandlerMethodMapping#initHandlerMethods</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCandidateBeanNames()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #processCandidateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handlerMethodsInitialized</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">			processCandidateBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>processCandidateBean</code>方法中根据bean的类型调用由子类实现的<code>isHandler</code>方法判断是否是处理器，然后调用<code>detectHandlerMethods</code>方法寻找该处理器中的处理方法并注册。</p><p>来看下<code>RequestMappingHandlerMapping#isHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller<span class="class">.<span class="keyword">class</span>) ||</span></span><br><span class="line"><span class="class">			<span class="title">AnnotatedElementUtils</span>.<span class="title">hasAnnotation</span>(<span class="title">beanType</span>, <span class="title">RequestMapping</span>.<span class="title">class</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的<code>AnnotatedElementUtils#hasAnnotation</code>方法，最终会调用到<code>AnnotatedElementUtils#searchWithFindSemantics</code>方法，代码片段如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = (Class&lt;?&gt;) element;</span><br><span class="line">    <span class="keyword">if</span> (!Annotation<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)) </span>&#123;</span><br><span class="line">        <span class="comment">// Search on interfaces 在实现接口中查找</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; ifc : clazz.getInterfaces()) &#123;</span><br><span class="line">            T result = searchWithFindSemantics(ifc, annotationTypes, annotationName,</span><br><span class="line">                    containerType, processor, visited, metaDepth);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Search on superclass 在父类中查找</span></span><br><span class="line">        Class&lt;?&gt; superclass = clazz.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            T result = searchWithFindSemantics(superclass, annotationTypes, annotationName,</span><br><span class="line">                    containerType, processor, visited, metaDepth);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现这个地方查找是否有指定注解时，如果继承的类或实现的接口有相应的注解也是可以的，这个特性在某些情况下是很有用的，比如在自动配置类中可以利用这一特点，使用<code>@Bean</code>注解再配合<code>@Conditionalxxx</code>等注解实现按需注入Controller。我们只要定义一个<em>标记类/接口</em>，再在该类上注解<code>@Controller</code>或<code>@RequestMapping</code>，然后让需要按需注入的Controller继承这个<em>标记类/接口</em>即可。</p><blockquote><p>注意，在一般情况下使用<code>@Bean</code>或<code>@Component</code>注解是不能将一个Bean注册为Controller的</p></blockquote><h4 id="AbstractHandlerMethodMapping-detectHandlerMethods"><a href="#AbstractHandlerMethodMapping-detectHandlerMethods" class="headerlink" title="AbstractHandlerMethodMapping#detectHandlerMethods"></a>AbstractHandlerMethodMapping#detectHandlerMethods</h4><p>现在我们来看下这个自动发现机制中最关键的方法：</p><figure class="highlight java"><figcaption><span>AbstractHandlerMethodMapping#detectHandlerMethods</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">			obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 获取用户定义的类，防止在代理模式下不能获取到方法以及上面的注解</span></span><br><span class="line">		Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">           <span class="comment">// 返回方法及其相关元数据的一个map，元数据是回调lambda获取的，可以看下MetadataLookup#inspect函数式接口</span></span><br><span class="line">		Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">				(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">// 由子类实现的抽象方法</span></span><br><span class="line">                           <span class="comment">// 在RequestMappingHandlerMapping中是RequestMappingInfo</span></span><br><span class="line">						<span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">								userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(formatMappings(userType, methods));</span><br><span class="line">		&#125;</span><br><span class="line">		methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">               <span class="comment">// 获取该方法的可调用方法</span></span><br><span class="line">			Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">               <span class="comment">// 注册</span></span><br><span class="line">			registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>RequestMappingHandlerMapping#getMappingForMethod</code>中先检查是否注解了<code>@RequestMapping</code>，如果有则获取注解中的请求的路径，请求的方式（GET,POST,…)等等信息，封装到<code>RequestMappingInfo</code>中返回，具体的代码就不放了，还是很好理解的。</p><p>再来看下最后这个<code>AbstractHandlerMethodMapping#registerHandlerMethod</code>方法</p><figure class="highlight java"><figcaption><span>AbstractHandlerMethodMapping#registerHandlerMethod</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好理解，调用<code>mappingRegistry#register</code>方法进行注册，那这个<code>mappingRegistry</code>是什么东西呢？</p><blockquote><p><code>MappingRegistry</code>实际上就是<code>AbstractHandlerMethodMapping</code>类中的一个内部类，看名字很好理解：映射注册表，这个类中维护了存放映射信息的map</p></blockquote><h3 id="MappingRegistry"><a href="#MappingRegistry" class="headerlink" title="MappingRegistry"></a>MappingRegistry</h3><p><code>MappingRegistry</code>是<code>AbstractHandlerMethodMapping</code>类中的一个内部类，在其中维护了五个用于存放映射信息的Map：</p><figure class="highlight java"><figcaption><span>MappingRegistry类字段</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正意义上的注册表，以RequestMappingInfo为key</span></span><br><span class="line"><span class="comment">// MappingRegistration中存放请求映射信息RequestMappingInfo、处理器方法HandlerMethod（即标注了@RequestMapping的处理方法）、映射路径url、处理器name</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// RequestMappingInfo和HandlerMethod的map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, HandlerMethod&gt; mappingLookup = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// url(请求路径)和RequestMappingInfo的map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, T&gt; urlLookup = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 处理器name和处理器方法的map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;HandlerMethod&gt;&gt; nameLookup = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 处理器方法和跨域配置的map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;HandlerMethod, CorsConfiguration&gt; corsLookup = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="MappingRegistry-register"><a href="#MappingRegistry-register" class="headerlink" title="MappingRegistry#register"></a>MappingRegistry#register</h4><figure class="highlight java"><figcaption><span>MappingRegistry#register</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Assert that the handler method is not a suspending one.</span></span><br><span class="line">	<span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass()) &amp;&amp; KotlinDelegate.isSuspend(method)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported suspending handler method detected: "</span> + method);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 创建处理器方法</span></span><br><span class="line">		HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">		validateMethodMapping(handlerMethod, mapping);</span><br><span class="line">              <span class="comment">// 将映射信息和处理器方法放到map中</span></span><br><span class="line">		<span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line">		<span class="comment">// 获取映射的请求路径数组，在RequestMapping注解中可对一个方法指定多个映射路径</span></span><br><span class="line">		List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line">		<span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line">                  <span class="comment">// 放入map</span></span><br><span class="line">			<span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">		&#125;</span><br><span class="line">              <span class="comment">// 如果name存储策略不为空，将处理器name和处理器方法放到nameLookup map中</span></span><br><span class="line">		String name = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">                  <span class="comment">// 将处理器name和处理器方法放到nameLookup map中</span></span><br><span class="line">			addMappingName(name, handlerMethod);</span><br><span class="line">		&#125;</span><br><span class="line">              <span class="comment">// 跨域配置</span></span><br><span class="line">		CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line">		<span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">		&#125;</span><br><span class="line">              <span class="comment">// 将映射信息和MappingRegistration放到注册表Map</span></span><br><span class="line">		<span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法说白了，就是把处理器，处理器方法，请求映射信息等等信息放到Map中，看到这里可能会对<code>RequestMappingInfo</code>和 <code>MappingRegistration</code>这两个东西感到疑惑，其实很简单，前者是Spring容器启动时控制器自动发现机制根据方法上<code>@RequestMapping</code>注解中的信息封装的对象，<strong>决定了什么样的请求能命中那个处理器方法</strong>，这也是<code>MappingRegistry#registry</code>注册表中以<code>RequestMappingInfo</code>为key的原因，而<code>MappingRegistration</code>中封装了处理器<code>Handler</code>,处理器方法<code>HandlerMethod</code>信息。</p><br><p>所以现在能知道一个请求到来时是如何<strong>找到处理器方法</strong>并调用的了：</p><blockquote><p>根据请求的url到<code>MappingRegistry#urlLookup</code>字段中匹配，如果匹配上，则取出对应的<code>RequestMappingInfo</code>，再到<code>MappingRegistry#registry</code>字段中取出<code>MappingRegistration</code>，再取出<code>MappingRegistration</code>中的处理器<code>Handler</code>和方法<code>HandlerMethod</code>，反射调用完成请求。</p></blockquote><p>当然，这只是大概的流程。</p><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>Spring容器启动，注册处理器的流程分析完了。其实说白了，Spring容器注册控制器就是扫描容器中的bean然后检查是否是控制器Controller，然后将其中注解有<code>@RequestMapping</code>的方法注册为处理器方法。</p><p>其实<code>HandlerMapping</code>的实现类并不是只有<code>RequestMappingHandlerMapping</code>一个，但是是<code>AbstractHandlerMethodMapping</code>提供的<strong>主要的</strong>实现逻辑，而实现类只是提供了基础的判断：是否是处理器（<code>isHandler</code>)，获取请求映射信息<code>getMappingForMethod</code>等抽象方法，所以说如果在某些场景下需要实现自定义的<code>HandlerMapping</code>时我们可以通过继承<code>RequestMappingInfoHandlerMapping</code>然后重写<code>isHandler</code>和<code>getMappingForMethod</code>方法即可。（<code>RequestMappingHandlerMapping</code>继承自<code>RequestMappingInfoHandlerMapping</code>）</p><p>至于案例，以后有空了再补上</p></div><blockquote class="post-copyright"><div class="content"><span class="post-time">最后更新时间：<time datetime="2022-05-13T16:24:11.655Z" itemprop="dateUpdated">2022-05-14 00:24:11</time></span><br>转载注明出处：<a href="/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/" rel="external">https://lolico.me/2020/03/09/源码角度分析Spring容器启动阶段注册Controller处理器的流程/</a></div><footer><a href="https://lolico.me"><img src="/img/avatar.jpg" alt="萌面喵喵侠"> 萌面喵喵侠</a></footer></blockquote><div class="page-reward"><a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/" rel="tag">Web</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/&title=《源码角度分析Spring容器启动阶段注册Controller处理器的流程》 — 萌面喵喵侠&pic=https://lolico.me/img/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/&title=《源码角度分析Spring容器启动阶段注册Controller处理器的流程》 — 萌面喵喵侠&source=萌面喵喵侠的个人博客" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《源码角度分析Spring容器启动阶段注册Controller处理器的流程》 — 萌面喵喵侠&url=https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/&via=https://lolico.me" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/2020/03/10/%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">获取泛型参数的类型</h4></a></div><div class="waves-block waves-effect next"><a href="/2020/03/02/hello-world/" id="post-next" class="post-nav-link"><div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">Hello World</h4></a></div></nav><section class="comments" id="comments"><div id="gitalk-container"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>const gitalk=new Gitalk({clientID:"0f06d8c6e963192695db",clientSecret:"59650bb92bb41ad1bc07668bf4fab39ffeb785d9",repo:"c3b2a7.github.io",owner:"c3b2a7",admin:["c3b2a7"],id:"2020-03-09 16:09:08",title:document.title,distractionFreeMode:!1});gitalk.render("gitalk-container")</script></section></article><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><h3 class="reward-title"><i class="icon icon-quote-left"></i> 感谢投食~ <i class="icon icon-quote-right"></i></h3><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码"></div><label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg"><div class="reward-toggle-ctrol"><span class="reward-toggle-item wechat">微信</span> <span class="reward-toggle-label"></span> <span class="reward-toggle-item alipay">支付宝</span></div></label></div></div></div><footer class="footer"><div class="top"><p><span id="busuanzi_container_site_uv" style="display:none">站点总访客数：<span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" style="display:none">站点总访问量：<span id="busuanzi_value_site_pv"></span></span></p><p><span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span> <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span></p></div><div class="bottom"><p><span>萌面喵喵侠 &copy; 2018 - 2022</span> <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><div class="global-share" id="globalShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/&title=《源码角度分析Spring容器启动阶段注册Controller处理器的流程》 — 萌面喵喵侠&pic=https://lolico.me/img/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/&title=《源码角度分析Spring容器启动阶段注册Controller处理器的流程》 — 萌面喵喵侠&source=萌面喵喵侠的个人博客" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《源码角度分析Spring容器启动阶段注册Controller处理器的流程》 — 萌面喵喵侠&url=https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/&via=https://lolico.me" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lolico.me/2020/03/09/%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E6%B3%A8%E5%86%8CController%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li></ul></div><div class="page-modal wx-share" id="wxShare"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p><img src="data:image/png;base64,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" alt="微信分享二维码"></div><script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script><script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!0}</script><script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis">{tags}</div><time class="flex-col time">{date}</time></div></a></li></template><script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html><!-- rebuild by neat -->